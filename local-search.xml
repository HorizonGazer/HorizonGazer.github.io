<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用GATK4获取短变异</title>
    <link href="/2024/07/08/%E4%BD%BF%E7%94%A8GATK4%E8%8E%B7%E5%8F%96%E7%9F%AD%E5%8F%98%E5%BC%82/"/>
    <url>/2024/07/08/%E4%BD%BF%E7%94%A8GATK4%E8%8E%B7%E5%8F%96%E7%9F%AD%E5%8F%98%E5%BC%82/</url>
    
    <content type="html"><![CDATA[<h3 id="1-实验目的">1. 实验目的</h3><p>GATK (<strong>G</strong>enome <strong>A</strong>nalysis <strong>T</strong>ool<strong>k</strong>it)，它是用于分析高通量测序数据的命令行工具集合，主要侧重于变体发现。本实验将使用使用GATK4获取短变异。</p><p>实验步骤为：准备参考基因组其他文件构成BWA索引，将样本ZW177与参考基因进行比对，对重复reads进行排序和标记生成.sorted.dedup.bam文件  ，IGV可视化BAM文件，在单个样本上运行GATK HaplotypeCaller，使用GenotypeGVCFs进行联合变异的调用，使用FreeBayes进行联合变异调用，过滤变异体确保只有高质量的变异数据被用于后续的分析，基本的统计和比较不同的集合等过程。</p><h3 id="2-实验准备">2. 实验准备</h3><h4 id="2-1-实验平台">2.1 实验平台</h4><p>Linux JSvr01 3.10.0-1160.80.1.el7.x86_64 #1 SMP Tue Nov 8 15:48:59 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</p><h4 id="2-2-数据简述">2.2 数据简述</h4><table><thead><tr><th>数据</th><th>来源</th></tr></thead><tbody><tr><td><img src="/img/image-20231015194925726.png"></td><td>/work/cb-data/Variants_workshop_2020/*.fastq.gz</td></tr><tr><td>genome.fa</td><td>/work/cb-data/Variants_workshop_2020/genome</td></tr><tr><td><img src="/img/image-20231015195114150.png"></td><td>/work/cb-data/Variants_workshop_2020/premade_gvcf/</td></tr><tr><td><img src="/img/image-20231015195200421.png"></td><td>/work/cb-data/Variants_workshop_2020/processed_bams/</td></tr><tr><td><img src="/img/image-20231015195239274.png"></td><td>/work/cb-data/Variants_workshop_2020/scripts</td></tr></tbody></table><h4 id="2-3-软件配置">2.3 软件配置</h4><table><thead><tr><th>软件</th><th>版本</th><th>来源</th></tr></thead><tbody><tr><td>bwa</td><td>0.7.17-r1188</td><td>Linux</td></tr><tr><td>GATK(自行设置路径)</td><td>4.1.9.0</td><td>Linux</td></tr><tr><td>Samtools</td><td>1.7</td><td>Linux</td></tr><tr><td>vcftools</td><td>0.1.15</td><td>Linux</td></tr><tr><td>FileZilla</td><td>3.65.0</td><td><a href="https://filezilla-project.org/">https://filezilla-project.org/</a></td></tr><tr><td>IGV</td><td>2.6.3</td><td><a href="https://data.broadinstitute.org/igv/projects/downloads/2.6/">https://data.broadinstitute.org/igv/projects/downloads/2.6/</a></td></tr></tbody></table><h3 id="3-实验内容">3. 实验内容</h3><p>本实验步骤为：准备参考基因组其他文件构成BWA索引，将样本ZW177与参考基因进行比对，对重复reads进行排序和标记生成.sorted.dedup.bam文件  ，IGV可视化BAM文件，在单个样本上运行GATK HaplotypeCaller，使用GenotypeGVCFs进行联合变异的调用，使用FreeBayes进行联合变异调用，过滤变异体确保只有高质量的变异数据被用于后续的分析，基本的统计和比较不同的集合等过程。</p><h4 id="3-1-Data-used-in-the-exercise">3.1 <strong>Data used in the exercise</strong></h4><p>我们将使用 黑腹果蝇WGS配对末端Illumina数据与NCBI种质SRR1663608，SRR1663609，SRR1663610，SRR1663611，分别对应于样品ZW155，ZW177，ZW184和ZW185。为了加快计算速度，最初每个样本约1000万个读取对的数据已被下采样50%。</p><p>该练习包括这几个步骤：从 WGS Illumina 读取到 GATK 最佳实践中指定的四样本变体调用。要调用所有四个样本中的变体，需要对四个 FASTQ 文件对中的每一个执行从读取对齐到单倍型调用的所有步骤。在具有大内存的多 CPU 计算机上，可以并行启动此类运行。</p><h4 id="3-2-Log-in-to-your-workshop-machine">3.2  <strong>Log in to your workshop machine</strong></h4><h4 id="3-3-General-tips">3.3  <strong>General tips</strong></h4><p><strong>检查所有提供的 shell 脚本</strong>，例如，在文本编辑器(如nano或vim)中打开它们。阅读解释性评论。注意使用环境变量来简化和泛化脚本。例如，下面定义一个变量ACC：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ACC=SRR1663609<br></code></pre></td></tr></table></figure><p>每当脚本中出现 $ACC 或 ${ACC} 时，都会被解释为 SRR1663609 。请注意将长行分成以“\”字符结尾的较小部分的技术。对于bash来说，这仍然是一条很长的线，但对我们来说更容易阅读。</p><p>使用 top 命令监控活动的进度，最好在单独的窗口中运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top -u S20213281022<br></code></pre></td></tr></table></figure><p>这将显示动态更新的流程列表，最活跃的进程位于顶部。由于GATK工具是用Java编写的，因此 将看到最多的过程将是称为java的Java虚拟机。 在对齐阶段，要寻找的过程将是称为 bwa 的 BWA 对准器。 顶部列表中没有任何活动进程（消耗 CPU 时间）将表示 正在运行的任何脚本完成（或崩溃）。注意不同运行的内存使用情况（%MEM 列）。</p><p><strong>查看日志文件</strong>。每次运行脚本时，所有命令的屏幕输出都会保存到日志文件（例如，脚本 .log ）。尽管写入该文件的消息有时听起来很神秘，但它们通常允许用户确定当前正在运行计算的哪个阶段。它还包含有用的计时信息（各个阶段的开始和结束日期，经过的时间，预计到达时间）。若要查看日志文件，可以使用以下命令之一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">more script.log #  从头开始浏览文件<br>tail -100 script.log #  显示文件的最后100行<br>tail -f script.log #  连续显示入线<br></code></pre></td></tr></table></figure><p>当然， 也可以通过在文本编辑器中打开它来查看整个文件。</p><p><strong>查看工作目录</strong> （/$USER） 随着运行的进行，正在生成各种中间文件。偶尔执行 <code>ls -al</code> 将允许 查看这些文件以及它们的大小如何增加。如果即使脚本似乎已结束，也看不到预期的输出文件，通常意味着出了问题。检查屏幕日志文件以查找错误消息。</p><p><strong>可以断开连接</strong>。如果一个步骤花费的时间超过愿意等待的时间，可以断开与 VNC 或screen会话的连接（在 VNC 中，单击 VNC 窗口右上角的叉号，但不要  “注销”！所有程序和窗口将继续运行， 可以在以后重新连接时检查结果。此外，如果 通过 ssh 客户端（而不是 VNC）工作并且没有screen，只要 正在运行的脚本是通过 nohup 在后台提交的， 就可以安全地注销 ssh 会话（按照本练习中的建议）。下次登录到计算机时，脚本仍将运行（或已完成）。</p><h4 id="3-4-Fetch-input-files-and-scripts-to-your-local-scratch-directory">3.4  <strong>Fetch input files and scripts to your local scratch directory</strong></h4><p>准备所需的文件，放至工作目录下。</p><h5 id="1-创建文件夹">(1)   创建文件夹</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir S20213281022<br></code></pre></td></tr></table></figure><h5 id="2-复制文件至工作目录">(2)  复制文件至工作目录</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp ../Variants_workshop_2020/*.fastq.gz .<br>cp -r ../Variants_workshop_2020/scripts/ .<br>cp -r ../Variants_workshop_2020/genome/ .<br>ls -l<br></code></pre></td></tr></table></figure><img src="/img/image-20231015151247684.png"><p>需要注意的是，脚本文件需要可执行权限，可在/scripts目录下使用<code>chmod u+x *.sh</code>加权限。</p><h4 id="3-5-Prepare-reference-genome">3.5  <strong>Prepare reference genome</strong></h4><p>子目录基因组中的文件 genome.fa 是我们将读取对齐的参考。在启动管道之前，需要为BWA对准器索引基因组。此外，需要总结所有染色体的长度信息。</p><h5 id="1-修改脚本权限">(1)  修改脚本权限</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd scripts/<br>chmod u+x prepare_genome.sh<br></code></pre></td></tr></table></figure><h5 id="2-修改脚本路径">(2)  修改脚本路径</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># index reference genome for bwa, create fasta indexes (fai and dict)</span><br>TMP=/home/<span class="hljs-variable">$USER</span>/<span class="hljs-variable">$USER</span> <span class="hljs-comment"># 修改成自己的目录</span><br>GATKDIR=/programs/gatk-4.1.9.0<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GATKDIR</span>:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">cd</span> genome<br><span class="hljs-comment"># Genome summary files needed and by GATK tools</span><br>gatk CreateSequenceDictionary -R genome.fa  -O genome.dict<br>samtools faidx genome.fa<br><span class="hljs-comment"># index for BWA alignment</span><br>bwa index genome.fa<br><span class="hljs-comment"># index image file needed by some Spark-based tools (if used)</span><br>gatk --java-options <span class="hljs-string">&quot;-Djava.io.tmpdir=<span class="hljs-variable">$TMP</span>&quot;</span> BwaMemIndexImageCreator \<br>     -I genome.fa \<br>     -O genome.fa.img<br></code></pre></td></tr></table></figure><h5 id="3-运行脚本">(3)  运行脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>nohup ./scripts/prepare_genome.sh &gt;&amp; prepare_genome.log &amp;<br>top -u S20213281022<br>cd genome<br>ls -l<br></code></pre></td></tr></table></figure><p>该脚本将在后台运行，大约需要 10 分钟才能完成（在单独的窗口中使用 top -u $USER  来监视进程）。</p><img src="/img/image-20231015151933510.png"><img src="/img/image-20231015152513462.png"><p>完成后，列出子目录基因组的内容 。文件genome.fa.fai 和 genome.fa.dict 是简单的文本文件，总结了原始FASTA文件中的染色体大小和起始字节位置。这与其他文件构成 BWA 索引。</p><h5 id="4-查看工作日志">(4)  查看工作日志</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano ../prepare_genome.log<br></code></pre></td></tr></table></figure><img src="/img/image-20231015152650821.png"><h5 id="5-查看提供随机访问fasta-fastq文件接口的-fai文件">(5)  查看提供随机访问fasta/fastq文件接口的.fai文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano genome.fa.fai<br></code></pre></td></tr></table></figure><img src="/img/image-20231015152720055.png"><p>fai的格式：以\t分割，fasta 5列，fastq 6列:</p><ul><li><strong>NAME</strong> Name of this reference sequence</li><li><strong>LENGTH</strong> Total length of this reference sequence, in bases</li><li><strong>OFFSET</strong> Offset in the FASTA/FASTQ file of this sequence’s first base</li><li><strong>LINEBASES</strong> The number of bases on each line</li><li><strong>LINEWIDTH</strong> The number of bytes in each line, including the newline</li><li><strong>QUALOFFSET</strong> Offset of sequence’s first quality within the FASTQ file</li></ul><h5 id="6-查看用来reference-genome序列的dict文件">(6)  查看用来reference genome序列的dict文件</h5><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">nano genome.<span class="hljs-built_in">dict</span><br></code></pre></td></tr></table></figure><img src="/img/image-20231015152742001.png"><p>@SQ用于分割每一条染色体信息，第一列是染色体信息，第二列是染色体名字，第三列是M5码，第四列是来源 。</p><h4 id="3-6-Align-reads-to-reference">3.6  <strong>Align reads to reference</strong></h4><p>使用脚本aln_bwa.sh，将SRR1663609(样本ZW177)与参考基因进行比对，它立即将其转换为 BAM  格式的压缩二进制文件，相当于 SAM，但小了几倍。由于这种管道机制，bwa mem 的大型中间输出文件不需要写入磁盘。</p><p>在我们的练习中，每个样本在一个 Illumina 泳道上测序一次。</p><h5 id="1-修改脚本权限-2">(1)  修改脚本权限</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ../scripts<br>chmod u+x bwa_aln.sh<br>cd ..<br></code></pre></td></tr></table></figure><h5 id="2-执行脚本">(2)  执行脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">nohup ./scripts/bwa_aln.sh SRR1663608 ZW155 &gt;&amp; bwa_aln_SRR1663608.log &amp;<br>nohup ./scripts/bwa_aln.sh SRR1663609 ZW177 &gt;&amp; bwa_aln_SRR1663609.log &amp;<br>nohup ./scripts/bwa_aln.sh SRR1663610 ZW184 &gt;&amp; bwa_aln_SRR1663610.log &amp;<br>nohup ./scripts/bwa_aln.sh SRR1663611 ZW185 &gt;&amp; bwa_aln_SRR1663611.log &amp;<br>top -u S20213281022<br>ls -l<br></code></pre></td></tr></table></figure><img src="/img/image-20231015153143961.png"><img src="/img/image-20231015154113030.png"><h5 id="3-查看SRR1663609-bam">(3)  查看SRR1663609.bam</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">samtools view -h SRR1663609.bam | less<br></code></pre></td></tr></table></figure><img src="/img/image-20231015154214597.png"><h4 id="3-7-Sort-and-mark-duplicates">3.7  <strong>Sort and mark duplicates</strong></h4><p>在此步骤中，在先前获得的BAM文件中发现的任何重复片段现在将被标记为在下游分析中忽略，并且将根据基因组坐标对比对进行排序。生成的排序 BAM 文件也将编制索引。所有这些操作现在都由一个名为 MarkDuplicatesSpark 的单个 GATK 工具执行。</p><p>运行的结果将是文件 SRR1663609.sorted.dedup.bam ，并附有索引文件 SRR1663609.sorted.dedup.bai 。</p><h5 id="1-修改脚本权限-3">(1)  修改脚本权限</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd scripts<br>chmod u+x sort_dedup_index.sh<br></code></pre></td></tr></table></figure><h5 id="2-修改脚本">(2)  修改脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano sort_dedup_index.sh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>REFFASTA=./genome/genome.fa<br>GATKDIR=/programs/gatk-4.1.9.0<br>TMP=/home/<span class="hljs-variable">$USER</span>/<span class="hljs-variable">$USER</span> <span class="hljs-comment">#修改路径</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/jdk1.8.0_121<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GATKDIR</span>:<span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># run this script as follows</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#    nohup ./sort_dedup_index.sh SRR1663609 &gt;&amp; log &amp;</span><br><span class="hljs-comment">#</span><br>ACC=<span class="hljs-variable">$1</span><br><span class="hljs-comment"># Note: GATK will create its temporary files in $TMP which is on large local disk.</span><br><span class="hljs-comment"># This is safer than putting them in default /tmp, which is usually small</span><br><span class="hljs-built_in">echo</span> Dedup/sorting started<br><span class="hljs-built_in">date</span><br>gatk MarkDuplicatesSpark \<br>            -I <span class="hljs-variable">$&#123;ACC&#125;</span>.bam \<br>            -O <span class="hljs-variable">$&#123;ACC&#125;</span>.sorted.dedup.bam \<br>            -M <span class="hljs-variable">$&#123;ACC&#125;</span>.sorted.dedup.txt \<br>            --tmp-dir <span class="hljs-variable">$TMP</span> \<br>            --conf <span class="hljs-string">&#x27;spark.executor.cores=4&#x27;</span><br><span class="hljs-comment"># Separate indexing not needed if CREATE_INDEX true in MarkDuplicates</span><br><span class="hljs-comment">#echo Indexing started</span><br><span class="hljs-comment">#date</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#gatk --java-options &quot;-Djava.io.tmpdir=$TMP&quot; BuildBamIndex \</span><br><span class="hljs-comment">#    --INPUT=$ACC.sorted.dedup.bam</span><br><span class="hljs-built_in">echo</span> Run completed<br><span class="hljs-built_in">date</span><br></code></pre></td></tr></table></figure><h5 id="3-执行脚本">(3)  执行脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>nohup ./scripts/sort_dedup_index.sh SRR1663608 &gt;&amp; sort_dedup_index_SRR1663608.log &amp;<br>nohup ./scripts/sort_dedup_index.sh SRR1663609 &gt;&amp; sort_dedup_index_SRR1663609.log &amp;<br>nohup ./scripts/sort_dedup_index.sh SRR1663610 &gt;&amp; sort_dedup_index_SRR1663610.log &amp;<br>nohup ./scripts/sort_dedup_index.sh SRR1663611 &gt;&amp; sort_dedup_index_SRR1663611.log &amp;<br>top -u S20213281022<br></code></pre></td></tr></table></figure><p>脚本运行近5分钟。</p><img src="/img/image-20231015154945525.png"><h5 id="4-查看目录中文件">(4)查看目录中文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l<br></code></pre></td></tr></table></figure><p>生成了.sorted.dedup.bam文件，以及索引文件.sorted.dedup.bai文件</p><img src="/img/image-20231015155657392.png"><h5 id="5-使用samtools命令查看获取到的文件的比对状态汇总">(5) 使用samtools命令查看获取到的文件的比对状态汇总</h5><p>检查获取的文件的对齐统计信息摘要，运行 samtools 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">samtools flagstat SRR1663609.sorted.dedup.bam<br></code></pre></td></tr></table></figure><img src="/img/image-20231015155805035.png"><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tap">结果如下：<br>10209495 +<span class="hljs-number"> 0 </span>in total (QC-passed reads + QC-failed reads) <span class="hljs-comment"># 这部分指示总的测序读数，包括通过质量控制（QC-passed reads）和未通过质量控制（QC-failed reads）的读数。在这个例子中，共有10209495个读数，都通过了质量控制。</span><br>82057 +<span class="hljs-number"> 0 </span>secondary <span class="hljs-comment">#  这表示有82057个测序读数被标记为次要（secondary）。通常，次要的测序读数是与同一片段相关的其他读数，通常对于比对结果中的多对一比对情况。</span><br>0 +<span class="hljs-number"> 0 </span>supplementary <span class="hljs-comment">#  在这里，没有补充的测序读数。补充读数通常与主要的测序读数相关，用于补充详细信息或分割跨越引物结合位点的片段。</span><br>750524 +<span class="hljs-number"> 0 </span>duplicates <span class="hljs-comment">#  这表明有750524个测序读数被标记为重复。这些测序读数通常是PCR扩增或文库制备过程中的复制物。</span><br>9698015 +<span class="hljs-number"> 0 </span>mapped (94.99% : N/A) <span class="hljs-comment">#  这表示有9698015个测序读数成功比对到参考基因组，比例为94.99%。N/A表示这里没有提供与该比率相关的额外信息。</span><br>10127438 +<span class="hljs-number"> 0 </span>paired in sequencing <span class="hljs-comment">#  这表示共有10127438对测序片段被测序，每对片段包括一条read1和一条read2。</span><br>5063719 +<span class="hljs-number"> 0 </span>read1 <br>5063719 +<span class="hljs-number"> 0 </span>read2 <span class="hljs-comment">#这些数字表示分别有5063719个read1和5063719个read2。这对应于上述的10127438对测序片段。</span><br>8749418 +<span class="hljs-number"> 0 </span>properly paired (86.39% : N/A) <span class="hljs-comment">#  这表示有8749418个测序片段被正确地匹配，比例为86.39%。通常，&quot;properly paired&quot; 意味着read1和read2在参考基因组上的位置和方向都正确匹配。</span><br>9504024 +<span class="hljs-number"> 0 </span>with itself and mate mapped <span class="hljs-comment">#  这表示有9504024对测序片段的read1和read2都成功比对，并且它们彼此之间也成功比对到了。</span><br>111934 +<span class="hljs-number"> 0 </span>singletons (1.11% : N/A) <span class="hljs-comment">#  这表示有111934个测序片段是单端测序（singletons），未成功形成配对。</span><br>254130 +<span class="hljs-number"> 0 </span>with mate mapped to a different chr <span class="hljs-comment">#  这表示有254130对测序片段的read1和read2分别比对到了不同的染色体。</span><br>88723 +<span class="hljs-number"> 0 </span>with mate mapped to a different chr (mapQ&gt;=5) <span class="hljs-comment">#  这表示有88723对测序片段的read1和read2分别比对到了不同的染色体，并且其比对质量（mapQ）大于等于5。</span><br></code></pre></td></tr></table></figure><h4 id="3-8-Visualize-the-alignments-using-IGV">3.8  <strong>Visualize the alignments using IGV</strong></h4><h5 id="1-利用FilleZilla下载文件">(1)  利用FilleZilla下载文件</h5><p>SRR1663609.sorted.dedup.bam，SRR1663609.sorted.dedup.bam.bai，genome.fa</p><h5 id="2-使用IGV可视化SRR1663609-sorted-dedup-bam">(2) 使用IGV可视化SRR1663609.sorted.dedup.bam</h5><img src="/img/image-20231015165530800.png"><p>在IGV图中，灰色表示insert size正常，是常规reads。红色表示insert size大于预期，表示可能存在缺失突变。蓝色表示insert size小于预期，表示可能存在插入突变。紫色的部分说明了存在插入碱基，数字表示插入碱基的个数。当覆盖轨道为彩色时，表示核苷酸与参照碱基比对的差异查过20%,可以根据这个，判断这些点位的SNP。</p><p>本图出现较多的paired end reads中成对两条reads比对到了不同的染色体Mapping在chr3LHet：2,258,070bp左右，并且chr3LHet：2,257,400bp左右有一个read存在39bp的碱基插入。</p><h4 id="3-9-Run-GATK-HaplotypeCaller-on-individual-samples">3.9  <strong>Run GATK HaplotypeCaller on individual samples</strong></h4><p>在此步骤中，我们将在BAM文件上运行HaplotypeCaller，以生成感兴趣基因组区域中每个位点的每个样本的基因型似然信息。通常，这个区域将是整个基因组。为了节省时间，我们将专注于一条染色体chr2R。预期结果将是文件SRR1663609.g.vcf ，其中包含该样本的GVCF格式的中间基因分型数据 。</p><h5 id="1-修改脚本权限-4">(1) 修改脚本权限</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd scripts<br>chmod u+x hc.sh<br></code></pre></td></tr></table></figure><h5 id="2-修改脚本-2">(2)  修改脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano hc.sh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>REFFASTA=./genome/genome.fa<br>GATKDIR=/programs/gatk-4.1.9.0<br>TMP=/home/<span class="hljs-variable">$USER</span>/<span class="hljs-variable">$USER</span>  <span class="hljs-comment">#修改路径</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GATKDIR</span>:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/jdk1.8.0_121<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># We will run the genotyping on one chromosome only.</span><br><span class="hljs-comment"># Other chromosomes clould be handlen in separate runs,</span><br><span class="hljs-comment"># possibly in parallel..</span><br>REGION=chr2R<br>ACC=<span class="hljs-variable">$1</span><br><span class="hljs-comment"># multi-threading does not work well here - they recommend using Queue to</span><br><span class="hljs-comment"># parallelize over regions, or just manually run a few in parallel...</span><br><span class="hljs-built_in">echo</span> Genotyping <span class="hljs-keyword">for</span> <span class="hljs-variable">$ACC</span> started<br><span class="hljs-built_in">date</span><br>gatk --java-options <span class="hljs-string">&quot;-Xmx4g&quot;</span>  HaplotypeCaller \<br>      --tmp-dir <span class="hljs-variable">$TMP</span> \<br>     -R <span class="hljs-variable">$REFFASTA</span> \<br>     -I <span class="hljs-variable">$ACC</span>.sorted.dedup.bam  \<br>     -L <span class="hljs-variable">$REGION</span> \<br>     -ERC GVCF \<br>     --native-pair-hmm-threads 4 \<br>     --minimum-mapping-quality 30 \<br>     -O <span class="hljs-variable">$ACC</span>.g.vcf<br><span class="hljs-built_in">echo</span> Run ended<br><span class="hljs-built_in">date</span><br></code></pre></td></tr></table></figure><h5 id="3-运行脚本-2">(3)运行脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>nohup ./scripts/hc.sh SRR1663608 &gt;&amp; hc_SRR1663608.log &amp;<br>nohup ./scripts/hc.sh SRR1663609 &gt;&amp; hc_SRR1663609.log &amp;<br>nohup ./scripts/hc.sh SRR1663610 &gt;&amp; hc_SRR1663610.log &amp;<br>nohup ./scripts/hc.sh SRR1663611 &gt;&amp; hc_SRR1663611.log &amp;<br>top -u S20213281022<br></code></pre></td></tr></table></figure><img src="/img/image-20231015160359403.png"><p><strong>此步骤的估计运行时间为 1 小时</strong>，并且必须对其他 3 个样本重复此操作。出于本练习的目的，我们建议至少一个示例使用 <a href="http://hc.sh">hc.sh</a> 和脚本运行此步骤，并将预制的 *.g.vcf 文件和相应的索引文件 *.g.vcf.idx 复制到目录中。</p><h5 id="4-查看-g-vcf文件">(4)  查看  .g.vcf文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano SRR1663610.g.vcf<br></code></pre></td></tr></table></figure><img src="/img/image-20231015165857087.png"><p>VCF格式用于记录变异位点（SNP/InDel）的文件格式。</p><p>#开头注释部分</p><p>无#开头 主体部分，主体部分包含10列数据，主体部分每一行代表一个变异位点信息。</p><p>主体部分10列代表的意义：</p><p>1、CHROM 参考序列名 2、POS 变异位点所在的left-most位置（1-base position）。（发生变异的的位置的第一个碱基所在） 3、ID 变异位点ID。同时对应着dbSNP数据库中的ID，若没有，使用默认使用 。 4、REF 参考序列的等位基因（Allele）（等位碱基，即参考序列该位置的碱基类型及碱基数量） 5、ALT 变异位点的等位基因，若有多个，则使用逗号分隔。（变异位点碱基） 6、QUAL 变异位点的质量。Phred格式的数值，代表着此位点是纯合的概率。此值越大，概率越低，代表 着此位点是变异位点的可能性越大。 7、FILTER 此位点是否要被过滤掉。如果是PASS，则表示此位点可以考虑为变异位点。 8、INFO 变异位点的相关信息。 9、FORMAT 变异位点的格式，如GT：AD：DP：GQ：PL。10、SAMPLEs各个样本的值，由BAM文件中＠RG下的SM标签所决定。这些值对应着第九列的各种格式。 不同格式的值用冒号分开。每个样本对应着一列；多个样本则对应着多列，这种情况下列的数量 会超过10列。</p><h5 id="5-查看目录文件">(5)  查看目录文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l<br></code></pre></td></tr></table></figure><img src="/img/image-20231015165951361.png"><h4 id="3-10-Joint-variant-calling-with-GenotypeGVCFs">3.10  <strong>Joint variant calling with GenotypeGVCFs</strong></h4><p>在中间样本级文件 *.g.vcf 结果可用于联合调用所有四个样本的变体之前，必须  使用 GATK4 的工具 CombineGVCFs 将它们合并为单个多样本 g.vcf 文件。</p><h5 id="1-修改脚本权限-5">(1)  修改脚本权限</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd scripts<br>chmod u+x combineGVCFs.sh<br>chmod u+x genotypeGVCFs.sh<br>nano combineGVCFs.sh<br></code></pre></td></tr></table></figure><h5 id="2-修改脚本-3">(2)  修改脚本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>REFFASTA=./genome/genome.fa<br>GATKDIR=/programs/gatk-4.1.9.0<br>TMP=/home/<span class="hljs-variable">$USER</span>/<span class="hljs-variable">$USER</span>  <span class="hljs-comment">#  修改路径</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GATKDIR</span>:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/jdk1.8.0_121<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># the gVCFG files obyained before need to be combined to be used with GenotypeGVCFs tool</span><br>REGION=chr2R<br><span class="hljs-built_in">echo</span> Combining GVCFs started<br><span class="hljs-built_in">date</span><br>gatk CombineGVCFs \<br>     --tmp-dir <span class="hljs-variable">$TMP</span> \<br>     -R <span class="hljs-variable">$REFFASTA</span> \<br>     -L <span class="hljs-variable">$REGION</span> \<br>     --variant SRR1663608.g.vcf \<br>     --variant SRR1663609.g.vcf \<br>     --variant SRR1663610.g.vcf \<br>     --variant SRR1663611.g.vcf \<br>     -O all.g.vcf<br><span class="hljs-built_in">echo</span> Run ended<br><span class="hljs-built_in">date</span><br></code></pre></td></tr></table></figure><h5 id="3-运行合并脚本">(3)  运行合并脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>nohup ./scripts/combineGVCFs.sh &gt;&amp; combineGVCFs.log &amp;<br>top -u S20213281022<br></code></pre></td></tr></table></figure><p>运行时间：5-6 分钟。生成all.vcf文件 。</p><p><img src="/img/image-20231015170330836.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l -t<br></code></pre></td></tr></table></figure><img src="/img/image-20231015171157459.png"><h5 id="4-修改联合变异体的调用的脚本">(4)  修改联合变异体的调用的脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd scripts<br>nano genotypeGVCFs.sh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>REFFASTA=./genome/genome.fa<br>GATKDIR=/programs/gatk-4.1.9.0<br>TMP=/home/<span class="hljs-variable">$USER</span>/<span class="hljs-variable">$USER</span>  <span class="hljs-comment">#  修改路径</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GATKDIR</span>:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/jdk1.8.0_121<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># the gVCFG files obyained before need to be combined to be used with GenotypeGVCFs tool</span><br>REGION=chr2R<br><span class="hljs-built_in">echo</span> Joint genotyping started<br><span class="hljs-built_in">date</span><br>gatk  GenotypeGVCFs \<br>   -R <span class="hljs-variable">$REFFASTA</span> \<br>   --tmp-dir <span class="hljs-variable">$TMP</span> \<br>   -V all.g.vcf \<br>   -O all.vcf \<br>   -stand-call-conf 5<br><span class="hljs-built_in">echo</span> Run ended<br><span class="hljs-built_in">date</span><br></code></pre></td></tr></table></figure><h5 id="5-调用联合变异">(5)  调用联合变异</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>nohup ./scripts/genotypeGVCFs.sh &gt;&amp; genotypeGVCFs.log &amp;<br></code></pre></td></tr></table></figure><p>运行时间：5-6 分钟。生成all.vcf文件 。</p><img src="/img/image-20231015171533555.png"><h5 id="6-查看all-vcf文件">(6)  查看all.vcf文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano all.vcf<br></code></pre></td></tr></table></figure><img src="/img/image-20231015183527031.png"><h4 id="3-11-Joint-variant-calling-using-FreeBayes">3.11  <strong>Joint variant calling using FreeBayes</strong></h4><p>与GATK的HaplotypeCaller类似，FreeBayes使用基于单倍型的方法来检测变体，尽管实现方式不同。FreeBayes 的输入由所有涉及的样本的对齐 BAM 文件组成。我们将使用在本练习前面获得的已处理的 BAM 文件。结果将是变体文件 fb.vcf 。</p><h5 id="1-修改脚本权限-6">(1)  修改脚本权限</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd scripts<br>chmod u+x fb.sh<br>nano fb.sh<br></code></pre></td></tr></table></figure><h5 id="2-修改脚本-4">(2)  修改脚本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#  修改FB路径</span><br>FB=/work/miniconda3/envs/FreeBayes/bin/freebayes<br>REFFASTA=./genome/genome.fa<br><span class="hljs-built_in">echo</span> Started at<br><span class="hljs-built_in">date</span><br><span class="hljs-variable">$FB</span> -f <span class="hljs-variable">$REFFASTA</span> \<br>SRR1663608.sorted.dedup.bam \<br>SRR1663609.sorted.dedup.bam \<br>SRR1663610.sorted.dedup.bam \<br>SRR1663611.sorted.dedup.bam \<br>--min-mapping-quality 30 \<br>-r chr2R &gt; fb.vcf<br><span class="hljs-built_in">echo</span> Completed at<br><span class="hljs-built_in">date</span><br></code></pre></td></tr></table></figure><h5 id="3-运行脚本-3">(3)  运行脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>nohup ./scripts/fb.sh &amp;&gt;fb.log <br></code></pre></td></tr></table></figure><h5 id="4-检查生成的fb-vcf文件">(4)  检查生成的fb.vcf文件</h5><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">nano <span class="hljs-built_in">fb</span>.vcf<br></code></pre></td></tr></table></figure><img src="/img/image-20231015185534374.png"><p>检查生成的 VCF 文件时，注意 FreeBayes 生成的注释字段中的参数通常与 GATK 调用方发出的参数不同。</p><h4 id="3-12-Filter-variants">3.12  <strong>Filter variants</strong></h4><p>在前面的步骤中获得的 VCF 文件是原始结果，可能包含大量误报，具体取决于调用中使用的严格选项。由于调用步骤非常耗时，因此通常建议将这些选项设置为发出一组包含的变体，然后根据各种参数过滤此组。在GATK，选项 --stand-call-conf 控制要输出的变体的质量下限阈值（VCF 的 QUAL 字段）。此选项应设置为某个低值。</p><h5 id="1-从原始-all-vcf中提取QUAL大于60的变体子集">(1)  从原始 all.vcf中提取QUAL大于60的变体子集</h5><p>可以使用许多不同的工具完成原始变体集的过滤。在很多情况下，人们可以简单地使用标准的Linux文本解析工具，如grep，awk或sed。例如，要从原始 all 中提取 QUAL 大于 60 的变体子集.vcf我们可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 将VCF头行(包含“#”)提取到一个新的VCF文件中</span><br>grep &quot;#&quot; all.vcf &gt; all.qual60.vcf<br>nano all.qual60.vcf<br></code></pre></td></tr></table></figure><img src="/img/image-20231015185621014.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 处理非头行，仅当第六列(即QUAL所在的位置)大于60时才将它们附加到新文件中。</span><br>grep -v &quot;#&quot; all.vcf | awk &#x27;&#123;if($6&gt;60) print&#125;&#x27; &gt;&gt; all.qual60.vcf<br>nano all.qual60.vcf<br></code></pre></td></tr></table></figure><img src="/img/image-20231015185722716.png"><h5 id="2-使用VariantFiltration过滤">(2)  使用VariantFiltration过滤</h5><p>GATK提供了一个名为VariantFiltration的工具，它允许更复杂的过滤模式。使用此工具的示例脚本称为 filter_vcf.sh 。检查此脚本时，您会注意到应用于 SNP 的过滤条件与应用于插入缺失的过滤条件不同。为此，首先将 SNP 和插入缺失提取到单独的文件中，对这些文件进行过滤，然后将 SNP 和插入缺失过滤的文件合并回单个过滤文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 修改脚本权限</span><br>cd scripts<br>chmod u+x filter_vcf.sh <br>nano filter_vcf.sh <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#  修改脚本</span><br><span class="hljs-comment">#!/bin/bash</span><br>REFFASTA=./genome/genome.fa<br>GATKDIR=/programs/gatk-4.1.9.0<br>TMP=/home/<span class="hljs-variable">$USER</span>/<span class="hljs-variable">$USER</span>  <span class="hljs-comment">#  修改路径</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GATKDIR</span>:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/jdk1.8.0_121<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br>VCF=<span class="hljs-variable">$1</span>     <span class="hljs-comment"># this should be the name *without* .vcf extension!</span><br><span class="hljs-built_in">echo</span> Run started<br><span class="hljs-built_in">date</span><br><span class="hljs-comment"># Separate snps</span><br>gatk SelectVariants \<br>    --tmp-dir <span class="hljs-variable">$TMP</span> \<br>    -R <span class="hljs-variable">$REFFASTA</span> \<br>    -V <span class="hljs-variable">$VCF</span>.vcf \<br>    --select-type-to-include SNP \<br>    -O <span class="hljs-variable">$VCF</span>.snps.vcf<br><span class="hljs-comment"># Filter SNPs</span><br>gatk VariantFiltration \<br>    --tmp-dir <span class="hljs-variable">$TMP</span> \<br>    -R <span class="hljs-variable">$REFFASTA</span> \<br>    -V <span class="hljs-variable">$VCF</span>.snps.vcf \<br>    --filter-expression <span class="hljs-string">&quot;QD &lt; 2.0 || FS &gt; 60.0 || MQ &lt; 40.0 || ReadPosRankSum &lt; -8.0&quot;</span> \<br>    --filter-name <span class="hljs-string">&quot;my_snp_filter&quot;</span> \<br>    -O <span class="hljs-variable">$VCF</span>.snps.filtered.vcf<br><span class="hljs-comment"># Separate indels</span><br>gatk SelectVariants \<br>    --tmp-dir <span class="hljs-variable">$TMP</span> \<br>    -R <span class="hljs-variable">$REFFASTA</span> \<br>    -V <span class="hljs-variable">$VCF</span>.vcf \<br>    --select-type-to-include INDEL \<br>    -O <span class="hljs-variable">$VCF</span>.indels.vcf<br><span class="hljs-comment"># Filter indels</span><br>gatk VariantFiltration \<br>    --tmp-dir <span class="hljs-variable">$TMP</span> \<br>    -R <span class="hljs-variable">$REFFASTA</span> \<br>    -V <span class="hljs-variable">$VCF</span>.indels.vcf \<br>    --filter-expression <span class="hljs-string">&quot;QD &lt; 2.0 || FS &gt; 200.0&quot;</span> \<br>    --filter-name <span class="hljs-string">&quot;my_indel_filter&quot;</span> \<br>    -O <span class="hljs-variable">$VCF</span>.indels.filtered.vcf<br><span class="hljs-comment"># Merge filtered files</span><br>gatk --java-options <span class="hljs-string">&quot;-Djava.io.tmpdir=<span class="hljs-variable">$TMP</span>&quot;</span> MergeVcfs \<br>   -R <span class="hljs-variable">$REFFASTA</span> \<br>   -I <span class="hljs-variable">$VCF</span>.snps.filtered.vcf \<br>   -I <span class="hljs-variable">$VCF</span>.indels.filtered.vcf \<br>   -O <span class="hljs-variable">$VCF</span>.filtered.vcf \<br><span class="hljs-built_in">echo</span> Run ended<br><span class="hljs-built_in">date</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 执行脚本</span><br>cd ..<br>nohup ./scripts/filter_vcf.sh all &gt;&amp; filter_vcf.log &amp;<br>top -u S20213281022<br></code></pre></td></tr></table></figure><p><img src="/img/image-20231015190111246.png" alt=""></p><p>运行时间： 3 分钟。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 查看all.filtered.vcf文件</span><br>nano all.filtered.vcf<br></code></pre></td></tr></table></figure><img src="/img/image-20231015190148768.png"><p>过滤后的VCF文件将称为 all.filtered.vcf （相应的索引文件*.vcf.idx 也将被创建）。其他中间文件（具有单独的 SNP、插入缺失、过滤连同它们的索引）也会产生——这些可能会被删除。检查已过滤的VCF文件。请注意“筛选器”字段中的更改。而不是点“.”（无过滤信息），此字段现在将包含标志 PASS （通过过滤器的变体）和my_snp_filter 或 my_indel_filter （这两个字符串都是在过滤命令中定义的）–标记未通过相应过滤器的变体。</p><h4 id="3-13-Basic-stats-and-comparison-of-variant-sets">3.13  <strong>Basic stats and comparison of variant sets</strong></h4><h5 id="1-使用Linux命令">(1)  使用Linux命令</h5><p>给定一个VCF文件，其最简单的属性可以通过运行标准的Linux文本解析工具获得。例如，若要获取文件中的变体数，请运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -v &quot;#&quot; all.vcf | wc -l<br></code></pre></td></tr></table></figure><img src="/img/image-20231015190234965.png"><p>grep 过滤掉标题行并将其输出通过管道传输到 wc -l  中，后者计算剩余的行并在屏幕上显示结果）。要提取位于染色体chr2R上位置10000和20000之间的位点并将其保存在文件中，只需运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -v &quot;#&quot; all.vcf | awk &#x27;&#123;if($1==&quot;chr2R&quot; &amp;&amp; $2 &gt;=10000 &amp;&amp; $2 &lt;=20000) print&#125;&#x27;&gt; extracted_records<br>nano extracted_records<br></code></pre></td></tr></table></figure><img src="/img/image-20231015190324163.png"><p>（请注意，在这种情况下，染色体条件$1==“chr2R”并不是真正需要的，因为我们的VCF文件只包含chr2R的数据，但是，需要更一般的输入）。要快速找出有多少变体通过了过滤，只需键入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27;&#123;if($7==&quot;PASS&quot;) print&#125;&#x27; all.filtered.vcf | wc -l<br></code></pre></td></tr></table></figure><img src="/img/image-20231015190359799.png"><p>存在417825变体。</p><h5 id="2-使用GATK4的-Concordance-和-GenotypeConcordance-工具">(2)  使用GATK4的 Concordance 和 GenotypeConcordance 工具</h5><p>GATK4 提供了有趣的函数，一致性和基因型一致性，以汇总变体集的各种统计数据，并将其与从相同数据获得的另一个变体集进行比较，但使用不同的方法，例如。基于此功能的脚本var_compar.sh将比较任意两个VCF文件，例如all.vcf和fb.vcf（分别使用GATK4和FreeBayes获得）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 修改脚本权限</span><br>cd scripts<br>chmod u+x var_compar.sh<br>nano var_compar.sh <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#  修改脚本</span><br><span class="hljs-comment">#!/bin/bash</span><br>REFFASTA=./genome/genome.fa<br>GATKDIR=/programs/gatk-4.1.9.0<br>TMP=/home/<span class="hljs-variable">$USER</span>/<span class="hljs-variable">$USER</span>  <span class="hljs-comment">#  修改路径</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GATKDIR</span>:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/jdk1.8.0_121<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># Supply only core file names (i.e., without .vcf suffix) of the VCF files</span><br>VCF1=<span class="hljs-variable">$1</span><br>VCF2=<span class="hljs-variable">$2</span><br>SAMPLE=<span class="hljs-variable">$3</span><br><span class="hljs-comment"># variants in VCF2 will be called &quot;truth&quot;, and those from VCF1</span><br><span class="hljs-comment"># will be &quot;evaluated&quot; against them.</span><br><span class="hljs-comment"># Check site concordance between two variant sets</span><br>gatk --java-options <span class="hljs-string">&quot;-Xmx2g -Djava.io.tmpdir=<span class="hljs-variable">$TMP</span>&quot;</span> Concordance \<br>   -R <span class="hljs-variable">$REFFASTA</span> \<br>   --evaluation <span class="hljs-variable">$VCF1</span>.vcf  \<br>   --truth <span class="hljs-variable">$VCF2</span>.vcf \<br>   --summary <span class="hljs-variable">$VCF1</span>.<span class="hljs-variable">$VCF2</span>.comp.site_summary<br><span class="hljs-comment"># Check genotype concordance for sample SAMPLE</span><br>gatk --java-options <span class="hljs-string">&quot;-Xmx2g -Djava.io.tmpdir=<span class="hljs-variable">$TMP</span>&quot;</span> GenotypeConcordance \<br>   --CALL_VCF <span class="hljs-variable">$VCF1</span>.vcf  \<br>   --TRUTH_VCF <span class="hljs-variable">$VCF2</span>.vcf \<br>   --CALL_SAMPLE <span class="hljs-variable">$SAMPLE</span> \<br>   --TRUTH_SAMPLE <span class="hljs-variable">$SAMPLE</span> \<br>   --O <span class="hljs-variable">$VCF1</span>.<span class="hljs-variable">$VCF2</span>.comp<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 运行脚本</span><br>cd ..<br>./scripts/var_compar.sh fb all ZW155 &gt;&amp; var_compar.log &amp;<br>top -u S20213281022<br>ls -l<br></code></pre></td></tr></table></figure><img src="/img/image-20231015190702759.png"><img src="/img/image-20231015191038059.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 查看fb.all.comp.site_summary文件</span><br>nano fb.all.comp.site_summary<br></code></pre></td></tr></table></figure><img src="/img/image-20231015191058859.png"><p>从图中可知，使用GATK4，以all.vcf为原假设，在InDel中，大部分都是假阳性，只有8个是真阳性。 而使用FreeBayes，以fb.vcf为原假设，其中有79.2%的SNP都是真阳性，少部分为假阳性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 提供更详细的分析ZW155基因型一致性</span><br>nano fb.all.comp.genotype_concordance_summary_metrics<br>nano fb.all.comp.genotype_concordance_contingency_metrics<br>nano fb.all.comp.genotype_concordance_detail_metrics<br></code></pre></td></tr></table></figure><img src="/img/image-20231015191214629.png"><img src="/img/image-20231015191159629.png"><img src="/img/image-20231015191323980.png"><p>上面的命令将生成四个文件fb.all.comp.site_summary，其中包含站点一致性摘要，以及另外三个文件<br>(fb.all.comp.genotype_concordance_summary_metrics,fb.all.comp.genotype_concordance_detail_metrics,fb.all.comp.genotype_concordance_contingency_metrics)，并提供更详细的分析ZW155基因型一致性。</p><h5 id="3-使用-vcftools">(3)  使用 vcftools</h5><p>vcftools 是用于分析和操作VCF文件的流行工具包。以下是一些使用示例（在VCF文件上尝试）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vcftools --vcf all.vcf<br></code></pre></td></tr></table></figure><img src="/img/image-20231015191357889.png"><p>显示有四个样本，共423493个变异体。</p><p>提取变体子集(chr2R，1M和2M之间)并将其写入新的VCF文件 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vcftools --vcf all.vcf --chr chr2R --from-bp 1000000 --to-bp 2000000 --recode --recode-INFO-all -c &gt; subset.vcf<br>nano subset.vcf<br></code></pre></td></tr></table></figure><img src="/img/image-20231015191854446.png"><p>获取所有变体的等位基因频率并将其写入文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vcftools --vcf all.vcf --freq -c &gt; all.freqs<br>nano all.freqs<br></code></pre></td></tr></table></figure><img src="/img/image-20231015191932852.png"><p>比较两个VCF文件（将在文件fb.all.compare中打印出各种比较信息 ）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vcftools --vcf fb.vcf --diff all.vcf --out fb.all.compare<br></code></pre></td></tr></table></figure><img src="/img/image-20231015191953933.png"><p>发现fb.vcf和all.vcf，都至少含有399691个短变异。之前实验可得GATK4发现了423493个变异体。</p><h3 id="4-实验总结">4. 实验总结</h3><h4 id="4-1-实验结论">4.1 实验结论</h4><ul><li>在本次实验中，GATK4发现了423493个变异体，而FreeBayes发现399691个变异体。</li><li>使用GATK4，以all.vcf为原假设，在InDel中，大部分都是假阳性，只有8个是真阳性。 而使用FreeBayes，以fb.vcf为原假设，其中有79.2%的SNP都是真阳性，少部分为假阳性。</li></ul><h4 id="4-2-实验收获">4.2 实验收获</h4><ul><li>使用samtools命令查看获取到的文件的比对状态汇总。</li><li>使用GATK4以及FreeBayes调用短变异体 。</li><li>学习利用IGV可视化BAM等文件，分析其生物学意义。</li><li>了解BAM与VCF等格式文件。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Genomics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HW</tag>
      
      <tag>Linux</tag>
      
      <tag>Genomics</tag>
      
      <tag>GATK4</tag>
      
      <tag>SNP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用MAKER进行基因组注释</title>
    <link href="/2024/07/08/%E4%BD%BF%E7%94%A8MAKER%E8%BF%9B%E8%A1%8C%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B3%A8%E9%87%8A/"/>
    <url>/2024/07/08/%E4%BD%BF%E7%94%A8MAKER%E8%BF%9B%E8%A1%8C%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="1-实验目的">1. 实验目的</h2><p>在本实验中，我们将使用MAKER进行基因组注释，它的工作原理是将尽可能多的证据沿着基因组序列排列，然后协调所有这些信号，以确定可能的基因结构。证据可以是来自同一(或密切相关)生物体的转录物或蛋白质序列。这些序列可以来自公共数据库或来自自己的实验数据(例如RNASeq实验的转录组组装)。Maker还能够考虑到重复的元素。</p><p>Maker使用ab-initio预测器(如Augustus或SNAP)来改进其预测:这些软件工具能够通过使用统计模型分析基因组序列来进行基因结构预测。</p><p>在本实验中，将学习如何执行基因组注释，以及如何评估其质量，学习训练从头算预测器产生良好结果的重要步骤，最后，将学习如何使用IGV来可视化结果。</p><p>参考：<a href="https://training.galaxyproject.org/training-material/topics/genome-annotation/tutorials/annotation-with-maker/tutorial.html">https://training.galaxyproject.org/training-material/topics/genome-annotation/tutorials/annotation-with-maker/tutorial.html</a></p><h3 id="2-实验准备">2. 实验准备</h3><h4 id="2-1-实验平台">2.1 实验平台</h4><p>Linux JSvr01 3.10.0-1160.80.1.el7.x86_64 #1 SMP Tue Nov 8 15:48:59 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</p><h4 id="2-2-数据简述">2.2 数据简述</h4><table><thead><tr><th>数据</th><th>数据来源</th></tr></thead><tbody><tr><td>maker_tutorial.tgz</td><td>/work/cb-data/annotation2019</td></tr><tr><td>pyu_rnd1.maker.output.tgz</td><td>/work/cb-data/annotation2019</td></tr></tbody></table><h4 id="2-3-软件配置">2.3 软件配置</h4><table><thead><tr><th>软件</th><th>版本</th><th>来源</th></tr></thead><tbody><tr><td>FileZilla</td><td>3.65.0</td><td><a href="https://filezilla-project.org/">https://filezilla-project.org/</a></td></tr><tr><td>IGV</td><td>2.6.3</td><td><a href="https://data.broadinstitute.org/igv/projects/downloads/2.6/">https://data.broadinstitute.org/igv/projects/downloads/2.6/</a></td></tr><tr><td>BuildDatabase</td><td>2.0.1</td><td>/work/bin/RepeatModeler-2.0.1/</td></tr><tr><td>RepeatModeler</td><td>2.0.1</td><td>/work/bin/RepeatModeler-2.0.1/</td></tr><tr><td>maker</td><td>2.31.10</td><td>/work/bin/maker</td></tr><tr><td>mpiexec</td><td>1.5</td><td>/work/bin/maker/exe/mpich2/bin</td></tr></tbody></table><h3 id="3-实验内容">3. 实验内容</h3><p>在本实验中，将学习如何执行基因组注释，以及如何评估其质量，学习训练从头算预测器产生良好结果的重要步骤，最后，将学习如何使用IGV来可视化结果。</p><p>对于第一轮，我们将Maker配置为仅通过将EST和蛋白质与基因组对齐来构建基因模型。这将生成一个初稿注释，我们将在接下来的步骤中对其进行改进。</p><p>第二轮，我们使用SNAP进行从头算预测因子首次训练。在 Maker 中使用它之前，我们需要使用我们在前面步骤中生成的第一个注释草稿来训练它们。只有最好的评分基因（即那些有最强证据的基因）才会被保留来训练预测因子。“Ab-initio”意味着这些预测因子能够仅根据基因组的序列和物种特异性统计模型来预测基因组中基因的结构。他们不使用任何证据（例如EST或蛋白质）来预测基因，但他们需要用一组已经预测的基因进行训练。Maker能够使用EST和蛋白质证据，并将它们与几个从头预测因子的结果相结合，以预测共识基因模型。它允许检测没有EST或蛋白质对齐的区域的基因，还可以在有EST和/或蛋白质证据以及从头预测的区域改进基因结构。</p><p>第三轮，我们需要运行新一轮的Maker。由于证据在第一次运行时已经在基因组上对齐，我们可以按原样重用这些对齐。 但这一次，启用从头的基因预测，禁用直接从所有 EST 和蛋白质推断基因预测：现在我们希望 Maker 通过协调证据比对<em>和</em>从头基因预测来推断基因预测。为了获得更好的结果，我们将对 SNAP进行第二次训练，然后第三次（最后一次）运行 Maker。</p><h4 id="3-1-Prepare-working-directory">3.1  Prepare working directory</h4><p>准备文件，创建工作目录。</p><p>将“ /work/cb-data/annotation2019/” 目录下的 data 文件拷贝到“ ~/$USER” 目录下，并解压。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir $USER<br>mkdir $USER/tmp<br>cd $USER<br>cp ../annotation2019/maker_tutorial.tgz ./<br>tar -zxf maker_tutorial.tgz<br>cd maker_tutorial<br>ls -1<br></code></pre></td></tr></table></figure><p><img src="/img/image-20231021204216470.png" alt=""></p><h4 id="3-2-Maker-round-1-Map-known-genes-to-the-genome">3.2  Maker round 1 - Map known genes to the genome</h4><p>将已知基因映射到基因组中，包括：重复掩蔽和将已知的转录组/蛋白质序列与基因组对齐 。</p><h5 id="1-构建自定义的重复数据库">(1)  构建自定义的重复数据库</h5><p>这个步骤对于这个练习来说是可选的，因为它是一个非常小的基因组，不需要重复掩蔽就可以了。 当在做一个真实的项目时，可以从 <a href="https://www.girinst.org/repbase/">RepBase</a>，需要许可下载一个数据库，也可以用自己的基因组序列构建一个自定义的重复数据库。</p><p>RepeatModeler  是一个用于构建自定义数据库的软件。这里提供了用于构建重复数据库的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/$USER/maker_tutorial/example_02_abinitio<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> 可以删除路径环境变量</span><br>export PATH=$(echo $PATH | tr &#x27;:&#x27; &#x27;\n&#x27; | grep -v &#x27;/work/bin/RepeatModeler-2.0.1&#x27; | tr &#x27;\n&#x27; &#x27;:&#x27; | sed &#x27;s/:$//&#x27;)<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> 重新定义路径</span><br>export PATH=/work/bin/RepeatModeler-2.0.1:$PATH<br>BuildDatabase -name pyu pyu_contig.fasta<br>RepeatModeler -pa 4 -database pyu &gt;&amp; repeatmodeler.log<br>nano repeatmodeler.log<br></code></pre></td></tr></table></figure><p><img src="/img/image-20231021211215656.png" alt=""></p><p><img src="/img/image-20231021211641284.png" alt=""></p><p>运行结束后获得pyu-families.fa，将其提供给maker_opts.ctl文件的“rmlib= ”选项</p><h5 id="2-设置环境运行-Maker-并创建-Maker-控制文件">(2)  设置环境运行 Maker 并创建 Maker 控制文件</h5><p>Maker 中的每一步都是由 Maker 控制文件指定的。 “ maker -CTL” 命令将创建三个控制文件： maker_bopts.ctl, maker_exe.ctl, maker_opts.ctl.by</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=/work/bin/maker/bin:/work/bin/RepeatMasker:/work/bin/maker/exe/snap:$PATH<br>export ZOE=/work/bin/maker/exe/snap/Zoe<br>cd ~/$USER/maker_tutorial/example_02_abinitio<br>maker -CTL<br></code></pre></td></tr></table></figure><p><img src="/img/image-20231022101537615.png" alt=""></p><h5 id="3-修正控制文件-maker-opts-ctl">(3)  修正控制文件 maker_opts.ctl</h5><p>将修改后的文件放在相同的目录“example_02_abinitio” 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 在 maker_opts.ctl修改以下变量，分为两部分：</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 运行RepeatMasker的配置</span></span><br>model_org=simple  #  tells RepeatMasker to mask the low complexity sequence (e.g.“AAAAAAAAAAAAA”)<br>rmlib=   #  tells RepeatMasker not to mask repeat sequences like transposon elements. If you have a repeat fasta file (e.g. output fromRepeatModeler) that you need to mask, put the fasta file name next to “rmlib=”<br>softmask=1  #  tells RepeatMasker to do soft-masking which converts repeats to lower case, instead of hard-masking which converts repeats to “N”. &quot;Soft-masking&quot; is important so that short repeat sequences within genes can still be annotated as part of gene.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#  匹配文件pyu_est.fasta中转录序列与文件sp_protein.fasta中蛋白质序列到基因组以及推断证据支持基因模型中</span></span><br>genome=pyu_contig.fasta<br>est=pyu_est.fasta<br>protein=sp_protein.fasta  #   specify the fasta file names of the EST and protein sequences. In general, the EST sequence file contains the assembled transcriptome from RNA-seq data. The protein sequence file include proteins from closely related species or swiss-prot. If you have multiple protein or EST files, separate file names with &quot;,&quot;.<br>est2genome=1<br>protein2genome=1  #  tell MAKER to align the transcript sequences from the pyu_est.fasta file and protein sequences from the sp_protein.fasta file to the genome. These two files are used to define evidence supported gene model.<br>TMP=~/$USER/tmp #important for big genome, as the default /tmp is too small<br></code></pre></td></tr></table></figure><h5 id="4-利用screen执行重复序列屏蔽">(4)  利用screen执行重复序列屏蔽</h5><p>重复掩蔽和对齐。 这一步需要一个小时。在screen中运行。在命令中:“ mpiexec -n 2” 意味着你将使用 MPI 并行 Maker，并且一次使用两个线程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">screen<br>export PATH=/work/bin/maker/bin:/work/bin/RepeatMasker:/work/bin/maker/exe/snap:$PATH<br>export ZOE=/work/bin/maker/exe/snap/Zoe<br><br>cd ~/$USER/maker_tutorial/example_02_abinitio<br>/work/bin/maker/exe/mpich2/bin/mpiexec -n 2 maker -base pyu_rnd1 &gt;&amp; log1 &amp;<br></code></pre></td></tr></table></figure><p><img src="/img/image-20231022104332557.png" alt=""></p><p><img src="/img/image-20231022113838827.png" alt=""></p><p>Maker is now finished!!!</p><h4 id="3-3-Maker-round-2-Gene-prediction-using-SNAP">3.3  Maker round 2 - Gene prediction using SNAP</h4><p>使用 SNAP 进行基因预测</p><h5 id="1-训练一个SNAP基因模型">(1)  训练一个SNAP基因模型</h5><p>SNAP是从基因组进行从头算基因预测的软件。使用 SNAP做基因预测，将首先使用上一个生成的对齐结果训练 SNAP 模型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/$USER/maker_tutorial/example_02_abinitio<br>cp ~/annotation2019/pyu_rnd1.maker.output.tgz ./<br>tar xvfz pyu_rnd1.maker.output.tgz<br></code></pre></td></tr></table></figure><p>设置环境变量，如果是新session</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=/work/bin/maker/bin:/work/bin/RepeatMasker:/work/bin/maker/exe/snap:$PATH<br>export ZOE=/work/bin/maker/exe/snap/Zoe<br></code></pre></td></tr></table></figure><p>接下的命令将MAKER round 1的结果传递到输入文件，构造一个SNAP模型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir snap1<br>cd snap1<br>gff3_merge -d ../pyu_rnd1.maker.output/pyu_rnd1_master_datastore_index.log<br>maker2zff -l 50 -x 0.5 pyu_rnd1.all.gff  #   specify that only gene models with AED score&gt;0.5 and protein length&gt;50 are used for building models.<br></code></pre></td></tr></table></figure><p>生成了三个文件：pyu_rnd1.all.gff &amp; genome.ann &amp; genome.dna</p><p><img src="/img/image-20231022110139244.png" alt=""></p><p>maker2zff生成一个ZFF格式文件（genome.ann）和一个FASTA格式文件（genome.dna），过滤用于再次训练的高置信度基因，共有7个选项：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-c 由EST/mRNA-Seq比对确定的剪接位点的比例，默认0.5</span><br><span class="hljs-deletion">-e 与EST/mRNA-Seq比对重叠的外显子的比例，默认0.5</span><br><span class="hljs-deletion">-o 和任何证据（EST或者蛋白）重叠的外显子的比例，默认0.5</span><br><span class="hljs-deletion">-a 从头预测证实的剪接位点的比例，默认0</span><br><span class="hljs-deletion">-t 和从头预测结果重叠的外显子的比例，默认0</span><br><span class="hljs-deletion">-l mRNA翻译的蛋白质序列的最短长度</span><br><span class="hljs-deletion">-x 最大AED值，默认0.5</span><br><span class="hljs-deletion">-n 不过滤</span><br></code></pre></td></tr></table></figure><p>AED值：maker2使用注释编辑距离（AED）来评估基因组注释的准确性，AED是一个介于 0 和 1 之间的数字，衡量注释与支持它的evidence的拟合优度，0 表示与可用证据完全一致，1 表示缺乏对注释基因模型的支持</p><p>现在将运行以下命令来训练SNAP。训练SNAP的基本步骤是：首先对输入的基因模型进行过滤，然后立即捕获周围的基因组序列每个模型轨迹，最后使用这些捕获的片段生成HMM。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">fathom -categorize 1000 genome.ann genome.dna<br>fathom -export 1000 -plus uni.ann uni.dna<br>forge export.ann export.dna<br>hmm-assembler.pl pyu . &gt; ../pyu1.hmm<br>mv pyu_rnd1.all.gff ../<br>cd ..<br></code></pre></td></tr></table></figure><p>在此之后，将在 example_02_abinitio 目录中找到两个新文件:pyu_rnd1.all.gff:第一轮的gff文件，它是基于证据的基因。 pyu1.hmm:一个从基于证据的基因训练出来的隐藏马尔科夫模型。</p><p><img src="/img/image-20231022112811141.png" alt=""></p><h5 id="2-用SNAP去预测基因">(2)  用SNAP去预测基因</h5><p>直接修改 maker_opts。之前修改过的 CTL文件。在此之前，保存一个maker_opts 的备份副本 CTL用于第一轮。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp maker_opts.ctl maker_opts.ctl_backup_rnd1<br></code></pre></td></tr></table></figure><p>修改文件maker_opts.ctl  中一些变量的值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">maker_gff= pyu_rnd1.all.gff<br>est_pass=1 # use est alignment from round 1<br>protein_pass=1 #use protein alignment from round 1<br>rm_pass=1 # use repeats in the gff file<br>snaphmm=pyu1.hmm<br>est= # remove est file, do not run EST blast again<br>protein= # remove protein file, do not run blast again<br>model_org= #remove repeat mask model, so not running RM again<br>rmlib= # not running repeat masking again<br>repeat_protein= #not running repeat masking again<br>est2genome=0 # do not do EST evidence based gene model<br>protein2genome=0 # do not do protein based gene model.<br>pred_stats=1 #report AED stats<br>alt_splice=0 # 0: keep one isoform per gene; 1: identify splicing variants of the same gene<br>keep_preds=1 # keep genes even without evidence support, set to 0 if no<br></code></pre></td></tr></table></figure><p>用新的控制文件运行 maker。这个步骤需要几分钟。 (一个真正的项目可能需要几个小时才能完成)。将使用选项“ -base pyu_rnd2” ，这样结果将被写入一个新目录“ pyu_rnd2” 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/work/bin/maker/exe/mpich2/bin/mpiexec -n 2 maker -base pyu_rnd2 &gt;&amp; log2 &amp;<br></code></pre></td></tr></table></figure><p><img src="/img/image-20231022113650745.png" alt=""></p><p><img src="/img/image-20231022113923968.png" alt=""></p><p>Maker is now finished!!!</p><h4 id="3-4-Maker-round-3-Retrain-SNAP-model-and-do-another-round-of-SNAP-gene-prediction">3.4  Maker round 3 - Retrain SNAP model and do another round of SNAP gene prediction</h4><p>重新训练 SNAP 模型，并进行另一轮 SNAP 基因预测，可能需要运行两到三轮 SNAP。所以你要再次重复第二部分。确保将 snap1 替换为 snap2，这样就不会覆盖上一轮。</p><h5 id="1-首先训练一个新的SNAP模型">(1)  首先训练一个新的SNAP模型</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir snap2<br>cd snap2<br>gff3_merge -d ../pyu_rnd2.maker.output/pyu_rnd2_master_datastore_index.log<br>maker2zff -l 50 -x 0.5 pyu_rnd2.all.gff<br>fathom -categorize 1000 genome.ann genome.dna<br>fathom -export 1000 -plus uni.ann uni.dna<br>forge export.ann export.dna<br>hmm-assembler.pl pyu . &gt; ../pyu2.hmm<br>mv pyu_rnd2.all.gff ..<br>cd ..<br></code></pre></td></tr></table></figure><h5 id="2-使用SNAP预测基因">(2)  使用SNAP预测基因</h5><p>为第二轮的maker_opts.ctl 保存副本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp maker_opts.ctl maker_opts.ctl_backup_rnd2<br></code></pre></td></tr></table></figure><p>编辑第三轮的maker_opts.ctl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">maker_gff=pyu_rnd2.all.gff<br>snaphmm=pyu2.hmm<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/work/bin/maker/exe/mpich2/bin/mpiexec -n 2 maker -base pyu_rnd3 &gt;&amp; log3 &amp;<br></code></pre></td></tr></table></figure><p><img src="/img/image-20231022114653929.png" alt=""></p><p>使用下面的命令创建最终的合并 gff 文件。 &quot; -n &quot;选项将产生一个没有基因组序列的 gff 文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gff3_merge -n -d pyu_rnd3.maker.output/pyu_rnd3_master_datastore_index.log&gt;pyu_rnd3.noseq.gff<br>fasta_merge -d pyu_rnd3.maker.output/pyu_rnd3_master_datastore_index.log<br></code></pre></td></tr></table></figure><p>在这之后，会得到一个新的 gff3 文件:pyu_rnd3.noseq.gff，以及蛋白质和转录 fasta 文件。</p><h5 id="3-生成AED图">(3)  生成AED图</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">/work/bin/maker/AED_cdf_generator.pl -b 0.025 pyu_rnd2.all.gff &gt; AED_rnd2<br>/work/bin/maker/AED_cdf_generator.pl -b 0.025 pyu_rnd3.all.gff &gt; AED_rnd3<br></code></pre></td></tr></table></figure><p>可以使用 Excel 绘制 AED_rnd2 和 AED_rnd3 文件的第二列，并使用第一列作为 x轴值。 x 轴标签为“AED” ， y 轴标签为“Cumulative Fraction of Annotations”</p><p><img src="/img/image-20231022145420930.png" alt=""></p><p><img src="/img/image-20231022145402231.png" alt=""></p><p>AED值：maker2使用注释编辑距离（AED）来评估基因组注释的准确性，AED是一个介于 0 和 1 之间的数字，衡量注释与支持它的evidence的拟合优度，0 表示与可用证据完全一致，1 表示缺乏对注释基因模型的支持。结合Cumulative Fraction of Annotations可进行质量评估。</p><h4 id="3-5-Visualize-the-gff-file-in-IGV">3.5  Visualize the gff file in IGV</h4><p>以将 gff 文件与fasta文件一起加载到 IGV 中。  用FileZilla下载pyu_contig.fasta和pyu_rnd1.all.gff，pyu_rnd2.all.gff，pyu_rnd3.all.gff文件。导入IGV进行可视化：</p><img src="/img/image-20231022153714959.png"><img src="/img/image-20231022165001764.png"><p>例如scf1117875582023:644,587-656,318，在第一轮结束时，Maker预测了该地区的部分短基因模型。 在第二轮之后，Maker能够预测该区域的其他基因模型。这意味着 Maker 主要使用 SNAP 的基因预测来构建此基因模型。 第三轮后，基于第二轮预测基因。训练SNAP可以完善基因结构并完善该区域发现的基因结构。</p><h3 id="4-实验总结">4. 实验总结</h3><h4 id="4-1-实验结论">4.1 实验结论</h4><p>第二个注释与前一个注释相比，具有更多的完整单拷贝，以及更多的基因使用从头预测因子可以在EST或蛋白质比对不足以预测基因的区域找到更多的基因。</p><p>第三轮训练中，Maker能够预测更复杂的基因，例如合并一些事先被认为是独立的基因，不需要超过两轮训练即可从从头预测器获得最佳结果。</p><h4 id="4-2-实验收获">4.2 实验收获</h4><p>学习了如何使用 Maker 注释真核基因组、训练SNAP并预测基因、如何评估注释的质量以及如何使用 IGV对结果进行可视化。</p>]]></content>
    
    
    <categories>
      
      <category>Genomics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HW</tag>
      
      <tag>Linux</tag>
      
      <tag>MAKER</tag>
      
      <tag>Genomics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DUT人工智能与专家系统_HW4</title>
    <link href="/2024/07/08/DUT%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F_HW4/"/>
    <url>/2024/07/08/DUT%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F_HW4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-上机要求">1  上机要求</h2><p>给定七种动物虎、金钱豹、斑马、长颈鹿、鸵鸟、企鹅、信天翁，编程实现基于产生式推理的七种动物识别专家系统。规则库如下，要求给定初始条件，能识别出是哪种动物。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs txt">规则库<br>r1： IF 该动物有毛发 THEN 该动物是哺乳动物<br>r2： IF 该动物有奶 THEN 该动物是哺乳动物<br>r3： IF 该动物有羽毛 THEN 该动物是鸟<br>r4： IF 该动物会飞 AND 会下蛋 THEN 该动物是鸟<br>r5： IF 该动物吃肉 THEN 该动物是食肉动物<br>r6： IF 该动物有犬齿 AND 有爪 AND 眼盯前方 THEN 该动物是食肉动物<br>r7： IF 该动物是哺乳动物 AND 有蹄 THEN 该动物是有蹄类动物<br>r8： IF 该动物是哺乳动物 AND 是反刍动物 THEN 该动物是有蹄类动物<br>r9： IF 该动物是哺乳动物 AND 是食肉动物 AND 是黄褐色 AND 身上有暗斑点 THEN 该动物是金钱豹<br>r10：IF 该动物是哺乳动物 AND 是食肉动物 AND 是黄褐色 AND 身上有黑色条纹 THEN 该动物是虎<br>r11：IF 该动物是有蹄类动物 AND 有长脖子 AND 有长腿 AND 身上有暗斑点 THEN 该动物是长颈鹿<br>r12：IF 该动物有蹄类动物 AND 身上有黑色条纹 THEN 该动物是斑马<br>r13：IF 该动物是鸟 AND 有长脖子 AND 有长腿 AND 不会飞 AND 有黑白二色 THEN 该动物是鸵鸟<br>r14：IF 该动物是鸟 AND 会游泳 AND 不会飞 AND 有黑白二色 THEN 该动物是企鹅<br>r15：IF 该动物是鸟 AND 善飞 THEN 该动物是信天翁<br></code></pre></td></tr></table></figure><h2 id="2-实现过程">2  实现过程</h2><h3 id="2-1-Python编程实现">2.1  Python编程实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 动物识别系统</span><br><br><span class="hljs-comment"># 规则库</span><br>txt_rule = <span class="hljs-string">&#x27;&#x27;&#x27;有毛发，是哺乳动物</span><br><span class="hljs-string">有奶，是哺乳动物</span><br><span class="hljs-string">有羽毛，是鸟</span><br><span class="hljs-string">会飞，会下蛋，是鸟</span><br><span class="hljs-string">吃肉，是肉食动物</span><br><span class="hljs-string">有犬齿，有爪，眼盯前方，是食肉动物</span><br><span class="hljs-string">是哺乳动物，有蹄，是蹄类动物</span><br><span class="hljs-string">是哺乳动物，是咀嚼反刍动物，是蹄类动物</span><br><span class="hljs-string">是哺乳动物，是食肉动物，是黄褐色，身上有暗斑点，金钱豹</span><br><span class="hljs-string">是哺乳动物，是肉食动物，是黄褐色，身上有黑色条纹，虎</span><br><span class="hljs-string">是蹄类动物，有长脖子，有长腿，身上有暗斑点，长颈鹿</span><br><span class="hljs-string">是蹄类动物，身上有黑色条纹，斑马</span><br><span class="hljs-string">是鸟，有长脖子，有长腿，不会飞，有黑白二色，鸵鸟</span><br><span class="hljs-string">是鸟，会游泳，不会飞，有黑白二色，企鹅</span><br><span class="hljs-string">是鸟，善飞，信天翁&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 特征值字典</span><br>character_dict = &#123;<span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;有毛发&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;有奶&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-string">&#x27;有羽毛&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-string">&#x27;会飞&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-string">&#x27;会下蛋&#x27;</span>,<br>                  <span class="hljs-string">&#x27;6&#x27;</span>: <span class="hljs-string">&#x27;吃肉&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-string">&#x27;有犬齿&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-string">&#x27;有爪&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>: <span class="hljs-string">&#x27;眼盯前方&#x27;</span>, <span class="hljs-string">&#x27;10&#x27;</span>: <span class="hljs-string">&#x27;有蹄&#x27;</span>,<br>                  <span class="hljs-string">&#x27;11&#x27;</span>: <span class="hljs-string">&#x27;是咀嚼反刍动物&#x27;</span>, <span class="hljs-string">&#x27;12&#x27;</span>: <span class="hljs-string">&#x27;是黄褐色&#x27;</span>, <span class="hljs-string">&#x27;13&#x27;</span>: <span class="hljs-string">&#x27;身上有暗斑点&#x27;</span>,<br>                  <span class="hljs-string">&#x27;14&#x27;</span>: <span class="hljs-string">&#x27;身上有黑色条纹&#x27;</span>, <span class="hljs-string">&#x27;15&#x27;</span>: <span class="hljs-string">&#x27;有长脖子&#x27;</span>, <span class="hljs-string">&#x27;16&#x27;</span>: <span class="hljs-string">&#x27;有长腿&#x27;</span>,<br>                  <span class="hljs-string">&#x27;17&#x27;</span>: <span class="hljs-string">&#x27;不会飞&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>: <span class="hljs-string">&#x27;会游泳&#x27;</span>, <span class="hljs-string">&#x27;19&#x27;</span>: <span class="hljs-string">&#x27;有黑白二色&#x27;</span>,<br>                  <span class="hljs-string">&#x27;20&#x27;</span>: <span class="hljs-string">&#x27;善飞&#x27;</span>, <span class="hljs-string">&#x27;21&#x27;</span>: <span class="hljs-string">&#x27;是哺乳动物&#x27;</span>, <span class="hljs-string">&#x27;22&#x27;</span>: <span class="hljs-string">&#x27;是鸟&#x27;</span>,<br>                  <span class="hljs-string">&#x27;23&#x27;</span>: <span class="hljs-string">&#x27;是食肉动物&#x27;</span>, <span class="hljs-string">&#x27;24&#x27;</span>: <span class="hljs-string">&#x27;是蹄类动物&#x27;</span>, &#125;<br><span class="hljs-comment"># 结果值字典</span><br>result_dict = &#123;<span class="hljs-string">&#x27;25&#x27;</span>: <span class="hljs-string">&#x27;信天翁&#x27;</span>, <span class="hljs-string">&#x27;26&#x27;</span>: <span class="hljs-string">&#x27;鸵鸟&#x27;</span>, <span class="hljs-string">&#x27;27&#x27;</span>: <span class="hljs-string">&#x27;斑马&#x27;</span>, <span class="hljs-string">&#x27;28&#x27;</span>: <span class="hljs-string">&#x27;长颈鹿&#x27;</span>,<br>               <span class="hljs-string">&#x27;29&#x27;</span>: <span class="hljs-string">&#x27;虎&#x27;</span>, <span class="hljs-string">&#x27;30&#x27;</span>: <span class="hljs-string">&#x27;金钱豹&#x27;</span>, <span class="hljs-string">&#x27;31&#x27;</span>: <span class="hljs-string">&#x27;企鹅&#x27;</span>&#125;<br><span class="hljs-comment"># 数据库对应的过程,合并两个字典</span><br>database = &#123;**character_dict, **result_dict&#125;<br><span class="hljs-comment"># 规则库数据转换为了列表</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data_list</span>():<br>    <span class="hljs-comment"># 用于储存中间过程</span><br>    data_process_list = []<br>    <span class="hljs-comment"># 用于存储过程对应的结果</span><br>    data_result_list = []<br>    <span class="hljs-comment"># 将规则库数据预处理</span><br>    data_str = txt_rule.split(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> data_str:<br>        data = data.split(<span class="hljs-string">&#x27;，&#x27;</span>)<br>        data_process_list.append(data[:-<span class="hljs-number">1</span>])<br>        data_result_list.append(data[-<span class="hljs-number">1</span>].replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))<br>    <span class="hljs-keyword">return</span> data_process_list, data_result_list<br><span class="hljs-comment"># 特征值字典转为提示词</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">character_dict_trans</span>():<br>    <span class="hljs-comment"># 使用enumerate()函数获取字典的键值对及其索引</span><br>    indexed_data = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">enumerate</span>(character_dict.items()))<br>    rsp_str = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment"># 使用for循环遍历这些键值对，每5个元素输出为1行</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(indexed_data), <span class="hljs-number">5</span>):<br>        line = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>            <span class="hljs-keyword">if</span> i + j &lt; <span class="hljs-built_in">len</span>(indexed_data):<br>                line += <span class="hljs-built_in">str</span>(indexed_data[i + j][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27;:&#x27;</span> + indexed_data[i + j][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) + <span class="hljs-string">&#x27;  &#x27;</span><br>        <span class="hljs-comment"># print(line)</span><br>        rsp_str += line + <span class="hljs-string">&#x27;\n&#x27;</span><br>    <span class="hljs-keyword">return</span> rsp_str<br><span class="hljs-comment"># 通过传入的列表寻找结果</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_data</span>(<span class="hljs-params">process_data_list, dict_output</span>):<br>    <span class="hljs-comment"># 依次进行循环查找并对过程排序</span><br>    <span class="hljs-keyword">for</span> index, data_process <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_process_list):<br>        <span class="hljs-comment"># 用于判断此过程是否成立</span><br>        num = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> process_data_list:<br>            <span class="hljs-keyword">if</span> data <span class="hljs-keyword">in</span> data_process:<br>                num += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 过程成立则数值相同，可以进入下一步</span><br>        <span class="hljs-keyword">if</span> num == <span class="hljs-built_in">len</span>(data_process):<br>            <span class="hljs-comment"># 此过程中结果是否为最终结果，不是将此过程结果加入到过程中</span><br>            <span class="hljs-keyword">if</span> data_result_list[index] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> result_dict.values():<br>                <span class="hljs-comment"># 弹出过程和此过程结果，因为此过程已经进行过，此结果存入需要查找的过程中</span><br>                result = data_result_list.pop(index)<br>                process = data_process_list.pop(index)<br>                <span class="hljs-comment"># 判断结果是否已经存在过程中，存在则重新寻找，不存在则加入过程，并将其存入最终结果</span><br>                <span class="hljs-keyword">if</span> result <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> process_data_list:<br>                    dict_output[<span class="hljs-string">&#x27;，&#x27;</span>.join(process)] = result<br>                    end_result = find_data(process_data_list + [result], dict_output)<br>                    <span class="hljs-keyword">if</span> end_result == <span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>                <span class="hljs-comment"># 存在则直接寻找</span><br>                <span class="hljs-keyword">else</span>:<br>                    end_result = find_data(process_data_list, dict_output)<br>                    <span class="hljs-keyword">if</span> end_result == <span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-comment"># 找到最终结果，取出结果后返回</span><br>            <span class="hljs-keyword">else</span>:<br>                process = data_process_list.pop(index)<br>                dict_output[<span class="hljs-string">&#x27;，&#x27;</span>.join(process)] = data_result_list[index]<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-comment"># 快速排序算法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    pivot = arr[<span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span>]<br>    left = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &lt; pivot]<br>    middle = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x == pivot]<br>    right = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &gt; pivot]<br>    <span class="hljs-keyword">return</span> quick_sort(left) + middle + quick_sort(right)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 规则库数据转换为了列表</span><br>    data_process_list, data_result_list = get_data_list()<br>    print_str_start = <span class="hljs-string">&#x27;&#x27;&#x27;输入对应条件前面的数字编号:</span><br><span class="hljs-string">*************************************************************</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>    print_str_end = <span class="hljs-string">&#x27;&#x27;&#x27;*************************************************************</span><br><span class="hljs-string">*********************当输入数字0时!程序结束******************</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 特征值字典转为提示词</span><br>    character_str = character_dict_trans()<br>    character_all_str = print_str_start + character_str + print_str_end<br>    <span class="hljs-built_in">print</span>(character_all_str)<br><br>    <span class="hljs-comment"># 存储用于查询的数据</span><br>    list_data = []<br>    <span class="hljs-comment"># 循环进行输入，直到碰见0后退出</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        input_num = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入数字编号：&quot;</span>)<br>        <span class="hljs-comment"># 当输入数字0时!程序结束</span><br>        <span class="hljs-keyword">if</span> input_num == <span class="hljs-string">&#x27;0&#x27;</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 输入数字编号，不在查询数据的列表中</span><br>        <span class="hljs-keyword">if</span> input_num <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> list_data:<br>            <span class="hljs-comment"># 则加入查询列表</span><br>            list_data.append(input_num)<br>    <span class="hljs-comment"># 将查询数字编号从小到大排序</span><br>    sorted_list_data = quick_sort([<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list_data])<br>    <span class="hljs-comment"># 打印查询条件</span><br>    list_data_str = [character_dict[<span class="hljs-built_in">str</span>(i)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sorted_list_data]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;查询条件为：&#x27;</span> + <span class="hljs-string">&#x27; &#x27;</span>.join(list_data_str) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <span class="hljs-comment"># 用于存储输出结果</span><br>    dict_output = &#123;&#125;<br>    <span class="hljs-comment"># 进行递归查找，直到找到最终结果,返回1则找到最终结果</span><br>    end_result = find_data(list_data_str, dict_output)<br>    <span class="hljs-comment"># 查找成功时</span><br>    <span class="hljs-keyword">if</span> end_result == <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;查询成功，推理过程如下：&#x27;</span>)<br>        <span class="hljs-comment"># 将结果进行打印</span><br>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dict_output.keys():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;data&#125;</span>-&gt;<span class="hljs-subst">&#123;dict_output[data]&#125;</span>&quot;</span>)<br>            <span class="hljs-comment"># 得到最终结果即输出所识别动物</span><br>            <span class="hljs-keyword">if</span> dict_output[data] <span class="hljs-keyword">in</span> result_dict.values():<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;所识别的动物为：<span class="hljs-subst">&#123;dict_output[data]&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 查找失败时</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;条件不足，无匹配规则，查询失败.&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-2-运行测试">2.2  运行测试</h3><p><img src="/img/image-20240506192441886.png" alt=""></p><h2 id="3-实验心得">3  实验心得</h2><p><strong>规则库</strong>：用于描述相应领域内知识的产生式集合</p><p><strong>综合数据库</strong>：一个用于存放问题求解过程中各种当前信息的数据结构</p><p><strong>控制系统</strong>：由一组程序组成，负责整个产生式系统的运行，实现对问题的求解。</p><p><strong>产生式表示法的特点</strong>：</p><ol><li>优点：自然性、模块性、有效性、清晰</li><li>缺点：效率不高、不能表达结构性知识</li></ol>]]></content>
    
    
    <categories>
      
      <category>人工智能与专家系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HW</tag>
      
      <tag>Python</tag>
      
      <tag>专家系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DUT人工智能与专家系统_HW3</title>
    <link href="/2024/07/08/DUT%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F_HW3/"/>
    <url>/2024/07/08/DUT%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F_HW3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-上机要求">1  上机要求</h2><ol><li>任选聚类算法和决策树算法中的一种算法编程实现。</li><li>任选BP神经网络和卷积神经网络中的一种模型编程实现手写体识别</li></ol><h2 id="2-聚类分析算法">2  聚类分析算法</h2><h3 id="2-1-聚类算法实现（K-Mean）">2.1  聚类算法实现（K-Mean）</h3><p>K-Mean聚类算法是一种简单的迭代型聚类算法，采用距离作为相似性指标，从而发现给定数据集中的K个类，且每个类有一个聚类中心，即质心，每个类的质心是根据类中所有值的均值得到的。</p><p>对于给定的一个包含 n个d 维数据点的数据集X及要分得的类别K,选取欧氏距离作为相似度指标。聚类目标是使得各类的聚类平方和最小，即最小化。</p><table><thead><tr><th>Step1</th><th>从数据集中随机选择k个数据，作为初始簇的均值向量</th></tr></thead><tbody><tr><td>Step2</td><td>对剩余的每个数据，根据其与各个簇均值向量的距离，将它划分给最近的簇</td></tr><tr><td>Step3</td><td>在新产生的k个簇的基础上，更新各个簇的均值向量</td></tr><tr><td>Step4</td><td>重复Step2-Step3,直到停止条件满足，如均值向量不再发生变化，或者达到最大迭代次数等</td></tr></tbody></table><h4 id="2-1-1-Python编程实现">2.1.1  Python编程实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  <br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_blobs  <br>  <br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">euclidean_distance</span>(<span class="hljs-params">x1, x2</span>):  <br>    <span class="hljs-comment"># 计算两个向量之间的欧氏距离</span><br>    <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">sum</span>((x1 - x2) ** <span class="hljs-number">2</span>)<br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kmeans</span>(<span class="hljs-params">X, k, max_iters=<span class="hljs-number">100</span></span>):  <br>    <span class="hljs-comment"># 1. 初始化质心  </span><br>    np.random.seed(<span class="hljs-number">0</span>)  <br>    indices = np.random.choice(<span class="hljs-built_in">len</span>(X), k, replace=<span class="hljs-literal">False</span>)  <br>    centroids = X[indices]  <br>  <br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_iters):  <br>        <span class="hljs-comment"># 2. 为每个数据点分配最近的质心  </span><br>        labels = np.array([np.argmin([euclidean_distance(x, centroid) <span class="hljs-keyword">for</span> centroid <span class="hljs-keyword">in</span> centroids]) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> X])  <br>  <br>        <span class="hljs-comment"># 3. 更新质心  </span><br>        new_centroids = np.array([X[labels == i].mean(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)])  <br>  <br>        <span class="hljs-comment"># 4. 检查质心是否改变  </span><br>        <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">all</span>(centroids == new_centroids):  <br>            <span class="hljs-keyword">break</span>  <br>  <br>        centroids = new_centroids  <br>  <br>    <span class="hljs-keyword">return</span> centroids, labels  <br>  <br><span class="hljs-comment"># 创建一个数据集  </span><br>X, _ = make_blobs(n_samples=<span class="hljs-number">300</span>, centers=<span class="hljs-number">4</span>, cluster_std=<span class="hljs-number">0.60</span>, random_state=<span class="hljs-number">0</span>)  <br>  <br><span class="hljs-comment"># 运行 K-means 算法  </span><br>centroids, labels = kmeans(X, k=<span class="hljs-number">5</span>)  <br>  <br><span class="hljs-comment"># 绘制结果  </span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt  <br>  <br>plt.scatter(X[:, <span class="hljs-number">0</span>], X[:, <span class="hljs-number">1</span>], c=labels, cmap=<span class="hljs-string">&#x27;viridis&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>, s=<span class="hljs-number">50</span>, linewidths=<span class="hljs-number">0</span>)  <br>plt.scatter(centroids[:, <span class="hljs-number">0</span>], centroids[:, <span class="hljs-number">1</span>], c=<span class="hljs-string">&#x27;red&#x27;</span>, marker=<span class="hljs-string">&#x27;x&#x27;</span>, s=<span class="hljs-number">200</span>, linewidths=<span class="hljs-number">3</span>)  <br>plt.show()<br></code></pre></td></tr></table></figure><h4 id="2-1-2-输出结果">2.1.2  输出结果</h4><p>输出结果如下，可知聚类效果较好。</p><p><img src="/img/image-20240506194640403.png" alt=""></p><h3 id="2-2-决策树算法实现（Decision-Tree）">2.2  决策树算法实现（Decision Tree）</h3><p>决策树（Decision Tree）是一种基本的分类与回归方法。决策树模型呈树形结构，在分类问题中，表示基于特征对数据进行分类的过程。它可以认为是if-then规则的集合。每个内部节点表示在属性上的一个测试，每个分支代表一个测试输出，每个叶节点代表一种类别。</p><p><strong>构建决策树的基本步骤</strong></p><ol><li>开始，所有记录看作一个节点</li><li>遍历每个特征的每一种分裂方式，找到最好的分裂特征（分裂点）</li><li>分裂成两个或多个节点</li><li>对分裂后的节点分别继续执行2-3步，直到每个节点足够“纯”为止。如果一个分裂点可以将当前的所有节点分为两类，使得每一类都很“纯”，也就是同一类的记录较多，那么就是一个好分裂点。</li></ol><p>下面就以一个经典的打网球的例子来说明如何构建决策树。我们今天是否去打网球（play）主要由天气（outlook）、温度（temperature）、湿度（humidity）、是否有风（windy）来确定。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">样本中共14条数据。<br><span class="hljs-literal">NO</span>. Outlook temperature humidity windy play <br> 1 sunny hot high <span class="hljs-literal">FALSE</span> <span class="hljs-literal">no</span> <br> 2 sunny hot high <span class="hljs-literal">TRUE</span> <span class="hljs-literal">no</span> <br> 3 overcast hot high <span class="hljs-literal">FALSE</span> <span class="hljs-literal">yes</span> <br> 4 rainy mild high <span class="hljs-literal">FALSE</span> <span class="hljs-literal">yes</span> <br> 5 rainy cool normal <span class="hljs-literal">FALSE</span> <span class="hljs-literal">yes</span> <br> 6 rainy cool normal <span class="hljs-literal">TRUE</span> <span class="hljs-literal">no</span> <br> 7 overcast cool normal <span class="hljs-literal">TRUE</span> <span class="hljs-literal">yes</span> <br> 8 sunny mild high <span class="hljs-literal">FALSE</span> <span class="hljs-literal">no</span> <br> 9 sunny cool normal <span class="hljs-literal">FALSE</span> <span class="hljs-literal">yes</span> <br> 10 rainy mild normal <span class="hljs-literal">FALSE</span> <span class="hljs-literal">yes</span> <br> 11 sunny mild normal <span class="hljs-literal">TRUE</span> <span class="hljs-literal">yes</span> <br> 12 overcast mild high <span class="hljs-literal">TRUE</span> <span class="hljs-literal">yes</span> <br> 13 overcast hot normal <span class="hljs-literal">FALSE</span> <span class="hljs-literal">yes</span> <br> 14 rainy mild high <span class="hljs-literal">TRUE</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><h4 id="2-2-1-Python编程实现">2.2.1  Python编程实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> operator<br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> *<br><br>mpl.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&quot;SimHei&quot;</span>]<br>mpl.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">createDataSet</span>():<br>    dataSet=[<br>                [<span class="hljs-string">&#x27;晴&#x27;</span>,<span class="hljs-string">&#x27;热&#x27;</span>,<span class="hljs-string">&#x27;高&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>],<br>                [<span class="hljs-string">&#x27;晴&#x27;</span>,<span class="hljs-string">&#x27;热&#x27;</span>,<span class="hljs-string">&#x27;高&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>],<br>                [<span class="hljs-string">&#x27;阴&#x27;</span>,<span class="hljs-string">&#x27;热&#x27;</span>,<span class="hljs-string">&#x27;高&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>                [<span class="hljs-string">&#x27;雨&#x27;</span>,<span class="hljs-string">&#x27;温&#x27;</span>,<span class="hljs-string">&#x27;高&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>                [<span class="hljs-string">&#x27;雨&#x27;</span>,<span class="hljs-string">&#x27;凉爽&#x27;</span>,<span class="hljs-string">&#x27;中&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>                [<span class="hljs-string">&#x27;雨&#x27;</span>,<span class="hljs-string">&#x27;凉爽&#x27;</span>,<span class="hljs-string">&#x27;中&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>],<br>                [<span class="hljs-string">&#x27;阴&#x27;</span>,<span class="hljs-string">&#x27;凉爽&#x27;</span>,<span class="hljs-string">&#x27;中&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>                [<span class="hljs-string">&#x27;晴&#x27;</span>,<span class="hljs-string">&#x27;温&#x27;</span>,<span class="hljs-string">&#x27;高&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>],<br>                [<span class="hljs-string">&#x27;晴&#x27;</span>,<span class="hljs-string">&#x27;凉爽&#x27;</span>,<span class="hljs-string">&#x27;中&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>                [<span class="hljs-string">&#x27;雨&#x27;</span>,<span class="hljs-string">&#x27;温&#x27;</span>,<span class="hljs-string">&#x27;中&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>            [<span class="hljs-string">&#x27;晴&#x27;</span>,<span class="hljs-string">&#x27;温&#x27;</span>,<span class="hljs-string">&#x27;中&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>           [<span class="hljs-string">&#x27;阴&#x27;</span>,<span class="hljs-string">&#x27;温&#x27;</span>,<span class="hljs-string">&#x27;高&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>            [<span class="hljs-string">&#x27;阴&#x27;</span>,<span class="hljs-string">&#x27;热&#x27;</span>,<span class="hljs-string">&#x27;中&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>             [<span class="hljs-string">&#x27;雨&#x27;</span>,<span class="hljs-string">&#x27;温&#x27;</span>,<span class="hljs-string">&#x27;高&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>]<br>                ]<br>    labels = [<span class="hljs-string">&#x27;天气&#x27;</span>,<span class="hljs-string">&#x27;温度&#x27;</span>,<span class="hljs-string">&#x27;湿度&#x27;</span>,<span class="hljs-string">&#x27;是否有风&#x27;</span>]  <span class="hljs-comment">#两个特征</span><br>    <span class="hljs-keyword">return</span> dataSet,labels<br><br>dataset,dataLabels = createDataSet()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calcShannonEnt</span>(<span class="hljs-params">dataSet</span>):<br>    <span class="hljs-comment">#样本总个数</span><br>    totalNum = <span class="hljs-built_in">len</span>(dataSet)<br>    <span class="hljs-comment">#类别集合</span><br>    labelSet = &#123;&#125;<br>    <span class="hljs-comment">#计算每个类别的样本个数</span><br>    <span class="hljs-keyword">for</span> dataVec <span class="hljs-keyword">in</span> dataSet:<br>        label = dataVec[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> label <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> labelSet.keys():<br>            labelSet[label] = <span class="hljs-number">0</span><br>        labelSet[label] += <span class="hljs-number">1</span><br>    shannonEnt = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#计算熵值</span><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> labelSet:<br>        pi = <span class="hljs-built_in">float</span>(labelSet[key])/totalNum<br>        shannonEnt -= pi*math.log(pi,<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> shannonEnt<br><br><span class="hljs-comment">#按给定特征划分数据集:返回第featNum个特征其值为value的样本集合，且返回的样本数据中已经去除该特征</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">splitDataSet</span>(<span class="hljs-params">dataSet, featNum, featvalue</span>):<br>    retDataSet = []<br>    <span class="hljs-keyword">for</span> dataVec <span class="hljs-keyword">in</span> dataSet:<br>        <span class="hljs-keyword">if</span> dataVec[featNum] == featvalue:<br>            splitData = dataVec[:featNum]<br>            splitData.extend(dataVec[featNum+<span class="hljs-number">1</span>:])<br>            retDataSet.append(splitData)<br>    <span class="hljs-keyword">return</span> retDataSet<br><span class="hljs-comment">#选择最好的特征划分数据集</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">chooseBestFeatToSplit</span>(<span class="hljs-params">dataSet</span>):<br>    featNum = <span class="hljs-built_in">len</span>(dataSet[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span><br>    maxInfoGain = <span class="hljs-number">0</span><br>    bestFeat = -<span class="hljs-number">1</span><br>    <span class="hljs-comment">#计算样本熵值，对应公式中：H(X)</span><br>    baseShanno = calcShannonEnt(dataSet)<br>    <span class="hljs-comment">#以每一个特征进行分类，找出使信息增益最大的特征</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(featNum):<br>        featList = [dataVec[i] <span class="hljs-keyword">for</span> dataVec <span class="hljs-keyword">in</span> dataSet]<br>        featList = <span class="hljs-built_in">set</span>(featList)<br>        newShanno = <span class="hljs-number">0</span><br>        <span class="hljs-comment">#计算以第i个特征进行分类后的熵值，对应公式中：H(X|Y)</span><br>        <span class="hljs-keyword">for</span> featValue <span class="hljs-keyword">in</span> featList:<br>            subDataSet = splitDataSet(dataSet, i, featValue)<br>            prob = <span class="hljs-built_in">len</span>(subDataSet)/<span class="hljs-built_in">float</span>(<span class="hljs-built_in">len</span>(dataSet))<br>            newShanno += prob*calcShannonEnt(subDataSet)<br>        <span class="hljs-comment">#ID3算法：计算信息增益,对应公式中：g(X,Y)=H(X)-H(X|Y)</span><br>        infoGain = baseShanno - newShanno<br>        <span class="hljs-comment">#C4.5算法：计算信息增益比</span><br>        <span class="hljs-comment">#infoGain = (baseShanno - newShanno)/baseShanno</span><br>        <span class="hljs-comment">#找出最大的熵值以及其对应的特征</span><br>        <span class="hljs-keyword">if</span> infoGain &gt; maxInfoGain:<br>            maxInfoGain = infoGain<br>            bestFeat = i<br>    <span class="hljs-keyword">return</span> bestFeat<br><br><span class="hljs-comment"># 如果决策树递归生成完毕，且叶子节点中样本不是属于同一类，则以少数服从多数原则确定该叶子节点类别</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">majorityCnt</span>(<span class="hljs-params">labelList</span>):<br>    labelSet = &#123;&#125;<br>    <span class="hljs-comment"># 统计每个类别的样本个数</span><br>    <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> labelList:<br>        <span class="hljs-keyword">if</span> label <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> labelSet.keys():<br>            labelSet[label] = <span class="hljs-number">0</span><br>        labelSet[label] += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># iteritems：返回列表迭代器</span><br>    <span class="hljs-comment"># operator.itemgeter(1):获取对象第一个域的值</span><br>    <span class="hljs-comment"># True：降序</span><br>    sortedLabelSet = <span class="hljs-built_in">sorted</span>(labelSet.items(), key=operator.itemgetter(<span class="hljs-number">1</span>), reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> sortedLabelSet[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">#创建决策树</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">createDecideTree</span>(<span class="hljs-params">dataSet, featName</span>):<br>    <span class="hljs-comment">#数据集的分类类别</span><br>    classList = [dataVec[-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> dataVec <span class="hljs-keyword">in</span> dataSet]<br>    <span class="hljs-comment">#所有样本属于同一类时，停止划分，返回该类别</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(classList) == classList.count(classList[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">return</span> classList[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">#所有特征已经遍历完，停止划分，返回样本数最多的类别</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dataSet[<span class="hljs-number">0</span>]) == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> majorityCnt(classList)<br>    <span class="hljs-comment">#选择最好的特征进行划分</span><br>    bestFeat = chooseBestFeatToSplit(dataSet)<br>    beatFestName = featName[bestFeat]<br>    <span class="hljs-keyword">del</span> featName[bestFeat]<br>    <span class="hljs-comment">#以字典形式表示树</span><br>    DTree = &#123;beatFestName:&#123;&#125;&#125;<br>    <span class="hljs-comment">#根据选择的特征，遍历该特征的所有属性值，在每个划分子集上递归调用createDecideTree</span><br>    featValue = [dataVec[bestFeat] <span class="hljs-keyword">for</span> dataVec <span class="hljs-keyword">in</span> dataSet]<br>    featValue = <span class="hljs-built_in">set</span>(featValue)<br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> featValue:<br>        subFeatName = featName[:]<br>        DTree[beatFestName][value] = createDecideTree(splitDataSet(dataSet,bestFeat,value), subFeatName)<br>    <span class="hljs-keyword">return</span> DTree<br><span class="hljs-comment">#print(createDecideTree(dataset,dataLabels))</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getNumLeafs</span>(<span class="hljs-params">tree</span>):<br>    numLeafs = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#获取第一个节点的分类特征</span><br>    firstFeat = <span class="hljs-built_in">list</span>(tree.keys())[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">#得到firstFeat特征下的决策树（以字典方式表示）</span><br>    secondDict = tree[firstFeat]<br>    <span class="hljs-comment">#遍历firstFeat下的每个节点</span><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():<br>        <span class="hljs-comment">#如果节点类型为字典，说明该节点下仍然是一棵树，此时递归调用getNumLeafs</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__== <span class="hljs-string">&#x27;dict&#x27;</span>:<br>            numLeafs += getNumLeafs(secondDict[key])<br>        <span class="hljs-comment">#否则该节点为叶节点</span><br>        <span class="hljs-keyword">else</span>:<br>            numLeafs += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> numLeafs<br><br><span class="hljs-comment">#获取决策树深度</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getTreeDepth</span>(<span class="hljs-params">tree</span>):<br>    maxDepth = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#获取第一个节点分类特征</span><br>    firstFeat = <span class="hljs-built_in">list</span>(tree.keys())[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">#得到firstFeat特征下的决策树（以字典方式表示）</span><br>    secondDict = tree[firstFeat]<br>    <span class="hljs-comment">#遍历firstFeat下的每个节点，返回子树中的最大深度</span><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():<br>        <span class="hljs-comment">#如果节点类型为字典，说明该节点下仍然是一棵树，此时递归调用getTreeDepth，获取该子树深度</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__ == <span class="hljs-string">&#x27;dict&#x27;</span>:<br>            thisDepth = <span class="hljs-number">1</span> + getTreeDepth(secondDict[key])<br>        <span class="hljs-keyword">else</span>:<br>            thisDepth = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> thisDepth &gt; maxDepth:<br>            maxDepth = thisDepth<br>    <span class="hljs-keyword">return</span> maxDepth<br><span class="hljs-comment">#画出决策树</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">createPlot</span>(<span class="hljs-params">tree</span>):<br>    <span class="hljs-comment"># 定义一块画布，背景为白色</span><br>    fig = plt.figure(<span class="hljs-number">1</span>, facecolor=<span class="hljs-string">&#x27;white&#x27;</span>)<br>    <span class="hljs-comment"># 清空画布</span><br>    fig.clf()<br>    <span class="hljs-comment"># 不显示x、y轴刻度</span><br>    xyticks = <span class="hljs-built_in">dict</span>(xticks=[], yticks=[])<br>    <span class="hljs-comment"># frameon：是否绘制坐标轴矩形</span><br>    createPlot.pTree = plt.subplot(<span class="hljs-number">111</span>, frameon=<span class="hljs-literal">False</span>, **xyticks)<br>    <span class="hljs-comment"># 计算决策树叶子节点个数</span><br>    plotTree.totalW = <span class="hljs-built_in">float</span>(getNumLeafs(tree))<br>    <span class="hljs-comment"># 计算决策树深度</span><br>    plotTree.totalD = <span class="hljs-built_in">float</span>(getTreeDepth(tree))<br>    <span class="hljs-comment"># 最近绘制的叶子节点的x坐标</span><br>    plotTree.xOff = -<span class="hljs-number">0.5</span> / plotTree.totalW<br>    <span class="hljs-comment"># 当前绘制的深度：y坐标</span><br>    plotTree.yOff = <span class="hljs-number">1.0</span><br>    <span class="hljs-comment"># （0.5,1.0）为根节点坐标</span><br>    plotTree(tree, (<span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span>), <span class="hljs-string">&#x27;&#x27;</span>)<br>    plt.show()<br><br><span class="hljs-comment"># 定义决策节点以及叶子节点属性：boxstyle表示文本框类型，sawtooth：锯齿形；fc表示边框线粗细</span><br>decisionNode = <span class="hljs-built_in">dict</span>(boxstyle=<span class="hljs-string">&quot;sawtooth&quot;</span>, fc=<span class="hljs-string">&quot;0.5&quot;</span>)<br>leafNode = <span class="hljs-built_in">dict</span>(boxstyle=<span class="hljs-string">&quot;round4&quot;</span>, fc=<span class="hljs-string">&quot;0.5&quot;</span>)<br><br><span class="hljs-comment"># 定义箭头属性</span><br>arrow_args = <span class="hljs-built_in">dict</span>(arrowstyle=<span class="hljs-string">&quot;&lt;-&quot;</span>)<br><br><br><span class="hljs-comment"># nodeText:要显示的文本；centerPt：文本中心点，即箭头所在的点；parentPt：指向文本的点；nodeType:节点属性</span><br><span class="hljs-comment"># ha=&#x27;center&#x27;，va=&#x27;center&#x27;:水平、垂直方向中心对齐；bbox：方框属性</span><br><span class="hljs-comment"># arrowprops：箭头属性</span><br><span class="hljs-comment"># xycoords，textcoords选择坐标系；axes fraction--&gt;0,0是轴域左下角，1,1是右上角</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plotNode</span>(<span class="hljs-params">nodeText, centerPt, parentPt, nodeType</span>):<br>    createPlot.pTree.annotate(nodeText, xy=parentPt, xycoords=<span class="hljs-string">&quot;axes fraction&quot;</span>,<br>                              xytext=centerPt, textcoords=<span class="hljs-string">&#x27;axes fraction&#x27;</span>,<br>                              va=<span class="hljs-string">&#x27;center&#x27;</span>, ha=<span class="hljs-string">&#x27;center&#x27;</span>, bbox=nodeType, arrowprops=arrow_args)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plotMidText</span>(<span class="hljs-params">centerPt, parentPt, midText</span>):<br>    xMid = (parentPt[<span class="hljs-number">0</span>] - centerPt[<span class="hljs-number">0</span>]) / <span class="hljs-number">2.0</span> + centerPt[<span class="hljs-number">0</span>]<br>    yMid = (parentPt[<span class="hljs-number">1</span>] - centerPt[<span class="hljs-number">1</span>]) / <span class="hljs-number">2.0</span> + centerPt[<span class="hljs-number">1</span>]<br>    createPlot.pTree.text(xMid, yMid, midText)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plotTree</span>(<span class="hljs-params">tree, parentPt, nodeTxt</span>):<br>    <span class="hljs-comment">#计算叶子节点个数</span><br>    numLeafs = getNumLeafs(tree)<br>    <span class="hljs-comment">#获取第一个节点特征</span><br>    firstFeat = <span class="hljs-built_in">list</span>(tree.keys())[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">#计算当前节点的x坐标</span><br>    centerPt = (plotTree.xOff + (<span class="hljs-number">1.0</span> + <span class="hljs-built_in">float</span>(numLeafs))/<span class="hljs-number">2.0</span>/plotTree.totalW, plotTree.yOff)<br>    <span class="hljs-comment">#绘制当前节点</span><br>    plotMidText(centerPt,parentPt,nodeTxt)<br>    plotNode(firstFeat,centerPt,parentPt,decisionNode)<br>    secondDict = tree[firstFeat]<br>    <span class="hljs-comment">#计算绘制深度</span><br>    plotTree.yOff -= <span class="hljs-number">1.0</span>/plotTree.totalD<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():<br>        <span class="hljs-comment">#如果当前节点的子节点不是叶子节点，则递归</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__ == <span class="hljs-string">&#x27;dict&#x27;</span>:<br>            plotTree(secondDict[key],centerPt,<span class="hljs-built_in">str</span>(key))<br>        <span class="hljs-comment">#如果当前节点的子节点是叶子节点，则绘制该叶节点</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment">#plotTree.xOff在绘制叶节点坐标的时候才会发生改变</span><br>            plotTree.xOff += <span class="hljs-number">1.0</span>/plotTree.totalW<br>            plotNode(secondDict[key], (plotTree.xOff,plotTree.yOff),centerPt,leafNode)<br>            plotMidText((plotTree.xOff,plotTree.yOff),centerPt,<span class="hljs-built_in">str</span>(key))<br>    plotTree.yOff += <span class="hljs-number">1.0</span>/plotTree.totalD<br><br><span class="hljs-comment">#决策树节点文本可以以中文显示</span><br><br><span class="hljs-comment">#创建决策树</span><br>myTree = createDecideTree(dataset,dataLabels)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;决策树模型：&quot;</span>)<br><span class="hljs-built_in">print</span>(myTree)<br>createPlot(myTree)<br><br><span class="hljs-comment">#预测部分</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">classify</span>(<span class="hljs-params">tree,feat,featValue</span>):<br>    firstFeat = <span class="hljs-built_in">list</span>(tree.keys())[<span class="hljs-number">0</span>]<br>    secondDict = tree[firstFeat]<br>    featIndex = feat.index(firstFeat)<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> secondDict.keys():<br>        <span class="hljs-keyword">if</span> featValue[featIndex] == key:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(secondDict[key]).__name__ == <span class="hljs-string">&#x27;dict&#x27;</span>:<br>                classLabel = classify(secondDict[key],feat,featValue)<br>            <span class="hljs-keyword">else</span>:<br>                classLabel = secondDict[key]<br>    <span class="hljs-keyword">return</span> classLabel<br><br>feat = [<span class="hljs-string">&#x27;天气&#x27;</span>,<span class="hljs-string">&#x27;温度&#x27;</span>,<span class="hljs-string">&#x27;湿度&#x27;</span>,<span class="hljs-string">&#x27;是否有风&#x27;</span>]<br>dataSet2=[<br>                [<span class="hljs-string">&#x27;晴&#x27;</span>,<span class="hljs-string">&#x27;温&#x27;</span>,<span class="hljs-string">&#x27;中&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>                [<span class="hljs-string">&#x27;阴&#x27;</span>,<span class="hljs-string">&#x27;温&#x27;</span>,<span class="hljs-string">&#x27;高&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>                [<span class="hljs-string">&#x27;阴&#x27;</span>,<span class="hljs-string">&#x27;热&#x27;</span>,<span class="hljs-string">&#x27;中&#x27;</span>,<span class="hljs-string">&#x27;否&#x27;</span>],<br>                [<span class="hljs-string">&#x27;雨&#x27;</span>,<span class="hljs-string">&#x27;温&#x27;</span>,<span class="hljs-string">&#x27;高&#x27;</span>,<span class="hljs-string">&#x27;是&#x27;</span>],<br>        ]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;预测结果：&quot;</span>)<br><span class="hljs-keyword">for</span> dataVec2 <span class="hljs-keyword">in</span> dataSet2:<br>    <span class="hljs-built_in">print</span>(classify(myTree,feat,dataVec2))<br></code></pre></td></tr></table></figure><h4 id="2-2-2-输出结果">2.2.2  输出结果</h4><p>输出结果如下。</p><p><img src="/img/image-20240506204213467.png" alt=""></p><p><img src="/img/image-20240506204229562.png" alt=""></p><h2 id="3-深度学习">3  深度学习</h2><h3 id="3-1-基于Keras的简单CNN架构的手写体识别">3.1  基于Keras的简单CNN架构的手写体识别</h3><p>Keras提供了可以很简单地创建卷积神经网络地API。在Keras中实现卷积神经网络，包括卷积层、池化层和全连接层。</p><ol><li>第一个隐藏层是一个称为Conv2D的卷积层。该层使用5×5的感受野，输出具有32个特征图，输入的数据具有input_shape参数所描述的特征，并采用ReLU作为激活函数。</li><li>定义一个采用最大值MaxPooling2D的池化层，并配置它在纵向和横向两个方向的采样因子(pool_size)为2×2,这表示图片在两个维度均变为原来的一半。</li><li>下一层是使用名为Dropout的正则化层，并配置为随机排除层中20%的神经元， 以减少过度拟合。</li><li>将多维数据转换为一维数据的Flatten层。它的输出便于标准的全连接层的处理。</li><li>具有128个神经元的全连接层，采用ReLU作为激活函数。</li><li>输出层有10个神经元，在MNIST数据集的输出具有10个分类，因此采用softmax函数，输出每张图片在每个分类上的得分。</li></ol><h4 id="3-1-1-Python编程实现">3.1.1  Python编程实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br> <br><span class="hljs-comment"># 导入数据集</span><br>mnist = tf.keras.datasets.mnist<br>(train_images, train_labels), (test_images, test_labels) = mnist.load_data()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集样本及标签&quot;</span>, train_images.shape, train_labels.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试集样本及标签&quot;</span>, test_images.shape, test_labels.shape)<br>train_images, test_images = train_images / <span class="hljs-number">255.0</span>, test_images / <span class="hljs-number">255.0</span>  <span class="hljs-comment"># 归一化,不然梯度爆炸</span><br><span class="hljs-comment"># 进行绘画</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">15</span>):<br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, i + <span class="hljs-number">1</span>)<br>    plt.xticks([])<br>    plt.yticks([])<br>    plt.grid(<span class="hljs-literal">False</span>)<br>    plt.imshow(test_images[i])<br>    plt.xlabel(test_labels[i])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/image-20240506210739707.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#训练CNN模型</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br> <br><span class="hljs-comment"># 导入数据集</span><br>mnist = tf.keras.datasets.mnist<br>(train_images, train_labels), (test_images, test_labels) = mnist.load_data()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集样本及标签&quot;</span>, train_images.shape, train_labels.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试集样本及标签&quot;</span>, test_images.shape, test_labels.shape)<br>train_images, test_images = train_images / <span class="hljs-number">255.0</span>, test_images / <span class="hljs-number">255.0</span>  <span class="hljs-comment"># 归一化,不然梯度爆炸</span><br> <br><span class="hljs-comment"># 建立各层神经网络</span><br>model = tf.keras.models.Sequential()  <span class="hljs-comment"># 建立一个堆叠层的神经网络</span><br><span class="hljs-comment"># 第一卷积层,32卷积核(即32输出通道),卷积核大小5x5,使用Relu激活函数,零值等大填充,输入张量形状28x28,色彩通道为1(即黑白图片)</span><br>model.add(tf.keras.layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>, input_shape=(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>)))<br><span class="hljs-comment"># 2x2的最大值池化</span><br>model.add(tf.keras.layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br><span class="hljs-comment"># 第二卷积层,64个输出通道，输入通道这里就不用指定，可以自动承接前一层的</span><br>model.add(tf.keras.layers.Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>))<br>model.add(tf.keras.layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)))<br><span class="hljs-comment"># 扁平化,将二维的张量变成一维,这里28x28经过两次2x2池化,已是7x7大小,现在变成49</span><br>model.add(tf.keras.layers.Flatten())<br><span class="hljs-comment"># 全连接层,64个神经元</span><br>model.add(tf.keras.layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br><span class="hljs-comment"># dropout层，损失函数0.5</span><br>model.add(tf.keras.layers.Dropout(<span class="hljs-number">0.5</span>))<br><span class="hljs-comment"># Readout层，输出独热编码</span><br>model.add(tf.keras.layers.Dense(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 最后输出10个数</span><br> <br><span class="hljs-comment"># 编译模型</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,  <span class="hljs-comment"># Adam优化器</span><br>              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="hljs-literal">True</span>),  <span class="hljs-comment"># 损失函数</span><br>              metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])  <span class="hljs-comment"># 监控指标:精度</span><br><span class="hljs-comment"># 开始训练,训练周期8,即将所有训练样本(6万个),遍历八遍,因为输入通道是32个,所以每遍训练1875次,每次32个</span><br>model.fit(train_images, train_labels, epochs=<span class="hljs-number">8</span>, validation_data=(test_images, test_labels))<br> <br><span class="hljs-comment"># 训练完毕，使用测试集来评估模型精度</span><br>test_loss, test_acc = model.evaluate(test_images, test_labels, verbose=<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n最终测试集上的精度为:&#x27;</span>, test_acc)<br> <br><span class="hljs-comment"># 保存模型</span><br>model.save(<span class="hljs-string">&quot;CNN模型.h5&quot;</span>) <br></code></pre></td></tr></table></figure><p><img src="/img/image-20240506211137542.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用训练好的卷积神经网络（CNN）模型对前50个测试集图像进行预测的过程。</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br> <br><span class="hljs-comment"># 导入数据集</span><br>mnist = tf.keras.datasets.mnist<br>(train_images, train_labels), (test_images, test_labels) = mnist.load_data()<br><span class="hljs-comment"># 加入待预测的图像及其标签</span><br>show_images, show_labels = test_images[<span class="hljs-number">0</span>:<span class="hljs-number">50</span>], test_labels[<span class="hljs-number">0</span>:<span class="hljs-number">50</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;所选取的测试集图片的标签is:&quot;</span>, show_labels)<br><span class="hljs-comment"># 引入模型</span><br>model = tf.keras.models.load_model(<span class="hljs-string">&quot;CNN模型.h5&quot;</span>)<br><span class="hljs-comment"># 开始预测</span><br>predictions = model.predict(show_images)<br><span class="hljs-comment"># 预测完成</span><br>predictions_num = tf.argmax(predictions, <span class="hljs-number">1</span>)<br><span class="hljs-comment"># 输出预测标签</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;所预测的标签为:&quot;</span>, predictions_num)<br></code></pre></td></tr></table></figure><p><img src="/img/image-20240506211325171.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#识别自己的手写体</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>  <br><span class="hljs-comment"># 读取一张自己手写的图片，此处为黑底白字</span><br>img_01 = tf.io.read_file(<span class="hljs-string">&#x27;C:/Users/汐/Desktop/手写体.png&#x27;</span>)  <br>img02 = tf.io.decode_png(img_01, channels=<span class="hljs-number">1</span>)<br>img03 = tf.image.resize(img02, [<span class="hljs-number">28</span>, <span class="hljs-number">28</span>])<br>img = (img03.numpy()).reshape([<span class="hljs-number">1</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;图片转化之后的形状为:&quot;</span>, img.shape)<br><span class="hljs-comment"># 运用模型进行预测</span><br>model = tf.keras.models.load_model(<span class="hljs-string">&quot;CNN模型.h5&quot;</span>)<br>predictions = model.predict(img)<br>predictions_num = tf.argmax(predictions, <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你的模型认为该数字为:&quot;</span>, predictions_num.numpy())<br></code></pre></td></tr></table></figure><h4 id="3-1-2-模型测试">3.1.2  模型测试</h4><p>输入的手写体为：</p><p><img src="/img/%E6%89%8B%E5%86%99%E4%BD%93.png" alt=""></p><p>模型识别结果为：</p><p><img src="/img/image-20240506211937432.png" alt=""></p><h3 id="3-2-基于Keras的BP手写体识别">3.2  基于Keras的BP手写体识别</h3><p>反向传播（英语：Backpropagation，缩写为BP）是“误差反向传播”的简称，是一种与最优化方法（如梯度下降法）结合使用的，用来训练人工神经网络的常见方法。该方法对网络中所有权重计算损失函数的梯度。这个梯度会反馈给最优化方法，用来更新权值以最小化损失函数。反向传播要求有对每个输入值想得到的已知输出，来计算损失函数梯度。因此，它通常被认为是一种监督式学习方法。反向传播要求人工神经元（或“节点”）的激励函数可微。</p><p>下面举一个简单的例子来介绍什么是梯度下降法以及如何训练神经网络。</p><p>假设有这样一个函数（ε是噪声）</p><p><img src="/img/BP-func.png" alt="BP-func"></p><p>但我们不知道参数的值，也就是w和b的值，但是我们直到很多（x,y）。那么我们可以通过这些值来预测原函数。</p><p>构造如下的损失函数</p><p><img src="/img/BP-lossfunc.png" alt="BP-lossfunc"></p><p>其中的x和y都是真实值，而w和b是我们要预测的值。我们预测的w和b应该使得损失函数越小越好，这点不难看出，损失函数越小证明我们预测出来的函数越接近真实情况。</p><p><img src="/img/BP-chart.png" alt="BP-chart"></p><p>假设我们得到的loss函数图像如上图所示，那么我们得目的就是找到一组w和b使得loss函数值处于一个极小值。</p><p><img src="/img/BP-dfunc.png" alt="BP-dfunc"></p><p>约定w和b按照上面得式子更新自己的值。其中w和b是原来的值，w’和b’是新值，lr是learning rate的缩写，直观理解就是横坐标移动的程度。根据高等数学的相关知识，我们知道函数梯度的方向指向极大值，所以上面式子用减号，也就达到了梯度下降的目的。梯度下降可以使得loss函数处于极小值。当然处于极小值不一定是处于最小值，可能会造成局部最优解，但这些问题超出了本篇实验报告的讨论范围，所以不作考虑。</p><p>经过若干次的更新w和b，我们就会找到一个较小的loss值，也就是说我们找到的w和b就很接近真实值了。</p><p>梯度下降是一种常用的优化loss函数的方法，还有其他的方法也可以对loss函数进行优化，例如随机梯度下降、Adagrad、Adam等。</p><p>下面介绍应用BP算法完成手写体识别问题。MNIST数据集的每一张图片是一个28x28的矩阵，每个元素是其位置的灰度信息。</p><p>我们首先将二维的矩阵打平成一维的，也就是说变成一个784x1的矩阵。上面介绍的简单的例子是单个数字，这里成了矩阵，所以我们的参数也应该是矩阵。</p><p>假设我们先将784x1的矩阵乘以一个512x784的矩阵参数，将得到一个512x1的矩阵</p><p>再将512x1的矩阵乘以一个256x512的矩阵参数，将得到一个256x1的矩阵</p><p>再将256x1的矩阵乘以一个10x256的矩阵参数，将得到一个10x1的矩阵</p><p>经过上述操作，我们将一个784x1的矩阵转换成了一个10x1的矩阵。为什么最后要转换成10个元素的矩阵？因为我们的手写体识别问题中有10个数字，最后我们得到的矩阵的每个元素代表的是可能是相应数字的概率。根据得到的概率和实际情况来构造损失函数，再利用梯度下降的方法来更新参数。</p><p>上述的好几步的矩阵转换操作实际上就是神经网络中的层，最后一步的10个元素属于输出层，第一次的784x1是输入层，中间的则是隐藏层。</p><h4 id="3-2-1-Python编程实现">3.2.1  Python编程实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> keras               <span class="hljs-comment">#keras框架导入</span><br><span class="hljs-keyword">from</span> keras.datasets <span class="hljs-keyword">import</span> mnist  <span class="hljs-comment">#数据集</span><br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense,Dropout  <span class="hljs-comment">#神经网络层导入</span><br><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential <span class="hljs-comment">#模型类型：Sequential序列模型和Model函数模型</span><br><br><span class="hljs-comment">#加载mnist数据集，(x_train,y_train)为训练样本， (x_test,y_test)测试样本</span><br>(x_train,y_train),(x_test,y_test)=mnist.load_data()<br><span class="hljs-comment">#数据归一化处理，将0~255归一化至 0~1之间，使得数据乘法运算也在0~1之间</span><br>x_train=x_train/<span class="hljs-number">255.0</span>  <span class="hljs-comment">#注意是255.0，发生浮点数运算，不是255</span><br>x_test=x_test/<span class="hljs-number">255.0</span><br><span class="hljs-comment">#mnist图像数据是28*28矩阵，全连接层是一排一排的数据形状，需要reshape为784(=28*28),</span><br><span class="hljs-comment">#无论数据结构/shape如何变化，图本身的特征并没有减少。</span><br>x_train=x_train.reshape(<span class="hljs-number">60000</span>,<span class="hljs-number">784</span>).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)  <span class="hljs-comment">#训练数据集60000个</span><br>x_test=x_test.reshape(<span class="hljs-number">10000</span>,<span class="hljs-number">784</span>).astype(<span class="hljs-string">&#x27;float32&#x27;</span>)   <span class="hljs-comment">#测试数据集10000个</span><br><br><span class="hljs-comment">#标签转one hot操作，将所有数据从1,2,3,4,...标注改编为</span><br><span class="hljs-comment"># 如 1 表达为【0,1,0,0,0,0,0,0,0,0】</span><br><span class="hljs-comment"># 如 5 表达为【0,0,0,0,0,1,0,0,0,0】</span><br>y_train=keras.utils.to_categorical(y_train,num_classes=<span class="hljs-number">10</span>)  <span class="hljs-comment">#10个类别</span><br>y_test =keras.utils.to_categorical(y_test,num_classes=<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">#搭建网络模型---全连接层</span><br>model=Sequential()  <span class="hljs-comment">#模型实例化</span><br><span class="hljs-comment">#向模型中添加Dense层为全连接层--类似面向过程的编程</span><br><span class="hljs-comment">#第一隐含层，untils为神经元个数（不能太大），input_shape为输入层输入结构，activation激活函数</span><br>model.add(Dense(units=<span class="hljs-number">128</span>,input_shape=(<span class="hljs-number">784</span>,),activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br><span class="hljs-comment">#第二层，这里不需要input_shape，自动以第一层结果作为输入</span><br>model.add(Dense(units=<span class="hljs-number">128</span>,activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br><span class="hljs-comment">#为防止过拟合，添加Dropout层，表示从所有学习的特征中随机扔掉25%不要，以预防前面过度学习。</span><br>model.add(Dropout(<span class="hljs-number">0.25</span>))<br><span class="hljs-comment">#输出层,手写数字共0~9十个类别</span><br>model.add(Dense(units=<span class="hljs-number">10</span>,activation=<span class="hljs-string">&#x27;softmax&#x27;</span>))<br><br><span class="hljs-comment">#模型编译---训练设置</span><br>model.<span class="hljs-built_in">compile</span>(loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>,optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><span class="hljs-comment">#启动训练</span><br>model.fit(<br>        x=x_train,<br>        y=y_train,<br>        batch_size=<span class="hljs-number">64</span>,<span class="hljs-comment">#每轮都是60000个样本，但不能将6万样本一次训练，那样所需内存过大，所以设置batch_size为每次训练样本数</span><br>        epochs=<span class="hljs-number">10</span>,<span class="hljs-comment">#训练多少轮次</span><br>        )<br><span class="hljs-comment">#模型测试</span><br>loss,acc=model.evaluate(x_test,y_test)<br><span class="hljs-built_in">print</span>(loss,acc)<br><span class="hljs-comment">#模型保存 --*.h5格式</span><br>model.save(<span class="hljs-string">&#x27;mnistTrain.h5&#x27;</span>)<br><br><span class="hljs-comment">#下面是测试代码</span><br><span class="hljs-comment">#应用模型测试</span><br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> load_model<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment">#加载要测试的数字图像</span><br>img_photo=Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;屏幕截图 2024-05-04 200823.png&#x27;</span>)<br><span class="hljs-comment">#统一数字图像大小为28*28</span><br>img_gray=img_photo.convert(<span class="hljs-string">&#x27;L&#x27;</span>)<br>img_to_array=np.array(img_gray.resize((<span class="hljs-number">28</span>,<span class="hljs-number">28</span>)))<br><span class="hljs-comment">#将数字图像矩阵数改为一排并归一化</span><br>img_to_array=img_to_array.reshape(<span class="hljs-number">1</span>,<span class="hljs-number">784</span>)/<span class="hljs-number">255.0</span><br><span class="hljs-comment">#加载模型</span><br>model=load_model(<span class="hljs-string">&#x27;mnistTrain.h5&#x27;</span>)<br><span class="hljs-comment">#进行预测</span><br>prediction=model.predict(img_to_array)<br><span class="hljs-comment">#输出预测值中最大概率对应下标即为所预测数字</span><br><span class="hljs-built_in">print</span>(np.argmax(prediction))<br></code></pre></td></tr></table></figure><h4 id="3-2-2-模型测试">3.2.2  模型测试</h4><p>输入手写体：</p><p><img src="/img/2024-05-04200823.png" alt=""></p><p>输出：</p><p><img src="/img/image-20240506213553975.png" alt=""></p><p>可见该模型识别手写体的准确性并不高。</p>]]></content>
    
    
    <categories>
      
      <category>人工智能与专家系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HW</tag>
      
      <tag>Python</tag>
      
      <tag>聚类分析算法</tag>
      
      <tag>手写体识别</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DUT人工智能与专家系统_HW2</title>
    <link href="/2024/07/08/DUT%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F_HW2/"/>
    <url>/2024/07/08/DUT%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F_HW2/</url>
    
    <content type="html"><![CDATA[<h2 id="1-上机要求">1  上机要求</h2><p>选择遗传算法、粒子群优化算法、蚁群算法算法解决旅行商问题(TSP)。要求给出最短长度和最短路径。</p><p>旅行商问题（Traveling Salesman Problem，TSP）是一种经典的组合优化问题，它涉及到在给定的一组城市之间找到最短的路径，使得每个城市都被访问一次。旅行商问题最早由爱德华·阿贝尔·哈密顿在19世纪提出，但直到20世纪才引起了人们的广泛关注。旅行商问题是一个NP难题，因此，寻找最优解的算法需要指数级的时间复杂度。</p><p>旅行商问题在许多领域都有应用，例如物流、电路板布线、DNA测序、图像处理等。在物流领域，旅行商问题可以用来优化货物的运输路线，从而降低运输成本。在电路板布线中，旅行商问题可以用来优化电路板上的连线，从而提高电路板的性能。在DNA测序中，旅行商问题可以用来优化DNA序列的测序顺序，从而提高测序的效率。在图像处理中，旅行商问题可以用来优化图像的压缩和重建，从而提高图像的质量。</p><p>为了解决旅行商问题，人们提出了许多求解算法。其中，最常用的算法包括贪心算法、动态规划算法、分支定界算法、模拟退火算法、遗传算法、蚁群算法、粒子群优化算法等。这些算法各有优缺点，可以根据具体问题的特点选择合适的算法。</p><h2 id="2-ACO解决TSP">2  ACO解决TSP</h2><p>蚁群算法（Ant Colony Optimization，ACO）是一种基于蚂蚁行为的优化算法，它模拟了蚂蚁在寻找食物时的行为。蚁群算法的基本原理是通过信息素和启发式规则来指导每个蚂蚁的移动，从而寻找最优解。在蚁群算法中，每个蚂蚁表示一个解，它们通过不断地释放和感知信息素来寻找最优解。</p><p>对于TSP问题，蚁群算法可以被用来寻找最短的路径。在蚁群算法中，我们将问题表示为一组蚂蚁，其中每个蚂蚁表示一个解。我们使用信息素和启发式规则来指导每个蚂蚁的移动，并使用适应度函数来评估每个蚂蚁的质量。在TSP问题中，适应度函数可以是路径长度。通过不断迭代，我们可以找到最短的路径。</p><p>具体来说，蚁群算法可以通过以下步骤来解决TSP问题：</p><ol><li>初始化信息素：将每条边的信息素初始化为一个较小的正数。</li><li>初始化蚂蚁：随机生成一组初始解，每个解表示一个蚂蚁。</li><li>选择下一个城市：根据信息素和启发式规则来选择下一个城市。</li><li>更新信息素：根据蚂蚁的路径长度来更新信息素。</li><li>重复步骤4，直到达到停止条件。</li><li>输出最优解：输出路径长度最短的蚂蚁的路径作为最优解。</li></ol><p>需要注意的是，蚁群算法的性能取决于参数的选择，例如信息素挥发率、信息素增量、启发式规则等。因此，在使用蚁群算法解决TSP问题时，需要进行参数调整以获得最佳性能。</p><h3 id="2-1-Python编程实现">2.1  Python编程实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  <br><br><span class="hljs-comment"># 设置参数  </span><br>num_ants = <span class="hljs-number">20</span>  <span class="hljs-comment"># 蚂蚁数量  </span><br>num_cities = <span class="hljs-number">10</span>  <span class="hljs-comment"># 城市数量  </span><br>num_iterations = <span class="hljs-number">100</span>  <span class="hljs-comment"># 迭代次数  </span><br>Q = <span class="hljs-number">1</span>  <span class="hljs-comment"># 信息素强度  </span><br>alpha = <span class="hljs-number">1</span>  <span class="hljs-comment"># 信息素重要程度因子  </span><br>beta = <span class="hljs-number">2</span>  <span class="hljs-comment"># 启发式因子重要程度  </span><br>rho = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># 信息素挥发率  </span><br><br><span class="hljs-comment"># 计算路径的总长度  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_path_length</span>(<span class="hljs-params">path, dist_matrix</span>):  <br>    length = <span class="hljs-number">0</span>  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(path) - <span class="hljs-number">1</span>):  <br>        length += dist_matrix[path[i], path[i + <span class="hljs-number">1</span>]]  <br>    <span class="hljs-comment"># 回到起点  </span><br>    length += dist_matrix[path[-<span class="hljs-number">1</span>], path[<span class="hljs-number">0</span>]]  <br>    <span class="hljs-keyword">return</span> length  <br>  <br><span class="hljs-comment"># 蚂蚁构建路径  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ant_build_path</span>(<span class="hljs-params">num_ants, num_cities, dist_matrix, pheromone_matrix, alpha, beta</span>):  <br>    paths = []  <br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_ants):  <br>        path = [np.random.randint(num_cities)]  <span class="hljs-comment"># 随机选择一个城市作为起点  </span><br>        visited = <span class="hljs-built_in">set</span>([path[<span class="hljs-number">0</span>]])  <br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(path) &lt; num_cities:  <br>            <span class="hljs-comment"># 计算每个未访问城市的概率  </span><br>            probabilities = (pheromone_matrix[path[-<span class="hljs-number">1</span>], :] ** alpha) * (<span class="hljs-number">1.0</span> / dist_matrix[path[-<span class="hljs-number">1</span>], :] ** beta)  <br>            probabilities[<span class="hljs-built_in">list</span>(visited)] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 将已访问城市的概率设为0  </span><br>            probabilities /= probabilities.<span class="hljs-built_in">sum</span>()  <br>            <span class="hljs-comment"># 根据概率选择下一个城市  </span><br>            next_city = np.random.choice(num_cities, p=probabilities)  <br>            path.append(next_city)  <br>            visited.add(next_city)  <br>        <span class="hljs-comment"># 回到起点  </span><br>        path.append(path[<span class="hljs-number">0</span>])  <br>        paths.append(path)  <br>    <span class="hljs-keyword">return</span> paths  <br>  <br><span class="hljs-comment"># 更新信息素  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_pheromone</span>(<span class="hljs-params">num_ants, num_cities, dist_matrix, paths, Q, rho</span>):  <br>    pheromone_matrix = np.ones((num_cities, num_cities))  <br>    <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> paths:  <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_cities):  <br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, num_cities):  <br>                <span class="hljs-keyword">if</span> j == path[i + <span class="hljs-number">1</span>] <span class="hljs-keyword">or</span> (i == num_cities - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j == path[<span class="hljs-number">0</span>]):  <span class="hljs-comment"># 找到路径中的边  </span><br>                    pheromone_matrix[i, j] += Q / calculate_path_length(path, dist_matrix)  <br>                    pheromone_matrix[j, i] = pheromone_matrix[i, j]  <span class="hljs-comment"># 信息素矩阵是对称的  </span><br>    <span class="hljs-comment"># 挥发信息素  </span><br>    pheromone_matrix *= (<span class="hljs-number">1</span> - rho) ** (num_ants)  <br>    <span class="hljs-keyword">return</span> pheromone_matrix  <br>  <br><span class="hljs-comment"># 蚁群算法主函数  </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ant_colony_optimization</span>(<span class="hljs-params">num_ants, num_cities, num_iterations, Q, alpha, beta, rho</span>):  <br>    <span class="hljs-comment"># 生成城市间的距离矩阵  </span><br>    np.random.seed(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 设置随机种子以获得可复现的结果  </span><br>    cities = np.random.rand(num_cities, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 在二维平面上随机生成城市坐标  </span><br>    dist_matrix = np.zeros((num_cities, num_cities))  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_cities):  <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, num_cities):  <br>            dist_matrix[i, j] = np.linalg.norm(cities[i] - cities[j])  <br>            dist_matrix[j, i] = dist_matrix[i, j]  <br>  <br>    <span class="hljs-comment"># 初始化信息素矩阵  </span><br>    pheromone_matrix = np.ones((num_cities, num_cities))  <br>  <br>    <span class="hljs-comment"># 记录最短路径和最短长度  </span><br>    shortest_path = <span class="hljs-literal">None</span>  <br>    shortest_length = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)  <br>  <br>    <span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_iterations):  <br>        <span class="hljs-comment"># 蚂蚁构建路径  </span><br>        paths = ant_build_path(num_ants, num_cities, dist_matrix, pheromone_matrix, alpha, beta)  <br>  <br>        <span class="hljs-comment"># 更新最短路径和最短长度  </span><br>        <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> paths:  <br>            length = calculate_path_length(path, dist_matrix)  <br>            <span class="hljs-keyword">if</span> length &lt; shortest_length:  <br>                shortest_length = length  <br>                shortest_path = path  <br>  <br>        <span class="hljs-comment"># 更新信息素  </span><br>        pheromone_matrix = update_pheromone(num_ants, num_cities, dist_matrix, paths, Q, rho)  <br>  <br>        <span class="hljs-comment"># 输出当前迭代的最短路径和长度  </span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Iteration <span class="hljs-subst">&#123;iteration + <span class="hljs-number">1</span>&#125;</span>/<span class="hljs-subst">&#123;num_iterations&#125;</span>, Best Length: <span class="hljs-subst">&#123;shortest_length&#125;</span>&quot;</span>)  <br>  <br>    <span class="hljs-keyword">return</span> shortest_length, shortest_path  <br>  <br><br><span class="hljs-comment"># 运行蚁群算法  </span><br>shortest_length, shortest_path = ant_colony_optimization(  <br>    num_ants, num_cities, num_iterations, Q, alpha, beta, rho  <br>)  <br>  <br><span class="hljs-comment"># 输出最终结果  </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Shortest Path Length: <span class="hljs-subst">&#123;shortest_length&#125;</span>&quot;</span>)  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Shortest Path: <span class="hljs-subst">&#123;shortest_path&#125;</span>&quot;</span>)  <br></code></pre></td></tr></table></figure><h3 id="2-2-输出结果">2.2  输出结果</h3><p>即展示前10次与后10次迭代结果。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/image-20240506232707625.png" alt=""></div><div class="group-image-wrap"><img src="/img/image-20240506232637443.png" alt=""></div></div></div><h2 id="3-PSO解决TSP">3  PSO解决TSP</h2><p>粒子群优化算法（Particle Swarm Optimization，PSO）是一种基于群体智能的优化算法，它模拟了鸟群或鱼群等群体的行为。粒子群算法的基本原理是通过不断地更新每个粒子的速度和位置来寻找最优解。在粒子群算法中，每个粒子表示一个解，它们通过不断地交流信息来寻找最优解。</p><p>对于TSP问题，粒子群算法可以被用来寻找最短的路径。在粒子群算法中，我们将问题表示为一组粒子，其中每个粒子表示一个解。我们使用速度和位置更新规则来移动每个粒子，并使用适应度函数来评估每个粒子的质量。在TSP问题中，适应度函数可以是路径长度。通过不断迭代，我们可以找到最短的路径。</p><p>具体来说，粒子群算法可以通过以下步骤来解决TSP问题：</p><ol><li>初始化粒子群：随机生成一组初始解，每个解表示一个粒子。</li><li>评估适应度：使用适应度函数来评估每个粒子的质量，适应度函数可以是路径长度。</li><li>更新速度和位置：使用速度和位置更新规则来移动每个粒子，以便它们可以更好地探索搜索空间。</li><li>更新最优解：记录全局最优解和每个粒子的最优解。</li><li>重复步骤4，直到达到停止条件。</li><li>输出最优解：输出全局最优解作为最优解。</li></ol><p>需要注意的是，粒子群算法的性能取决于参数的选择，例如粒子数量、惯性权重、加速度系数等。因此，在使用粒子群算法解决TSP问题时，需要进行参数调整以获得最佳性能。</p><h3 id="3-1-Python编码实现">3.1  Python编码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-comment"># 定义粒子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Particle</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_cities</span>):<br>        <span class="hljs-variable language_">self</span>.position = np.random.permutation(num_cities)<br>        <span class="hljs-variable language_">self</span>.velocity = np.zeros(num_cities, dtype=<span class="hljs-built_in">int</span>)<br>        <span class="hljs-variable language_">self</span>.best_position = np.copy(<span class="hljs-variable language_">self</span>.position)<br>        <span class="hljs-variable language_">self</span>.best_cost = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br><span class="hljs-comment"># 计算路径长度</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_cost</span>(<span class="hljs-params">position, distance_matrix</span>):<br>    cost = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(position)):<br>        cost += distance_matrix[position[i-<span class="hljs-number">1</span>], position[i]]<br>    <span class="hljs-keyword">return</span> cost<br><br><span class="hljs-comment"># 更新粒子的位置和速度</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_particle</span>(<span class="hljs-params">particle, global_best_position, distance_matrix</span>):<br>    <span class="hljs-comment"># 更新速度</span><br>    new_velocity = np.copy(particle.velocity)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(particle.position)):<br>        <span class="hljs-keyword">if</span> particle.position[i] != global_best_position[i]:<br>            new_velocity[i] = <span class="hljs-number">1</span> <span class="hljs-comment"># 表示需要变动</span><br>        <span class="hljs-keyword">else</span>:<br>            new_velocity[i] = <span class="hljs-number">0</span> <span class="hljs-comment"># 位置正确，不需要变动</span><br>    <br>    <span class="hljs-comment"># 更新位置</span><br>    new_position = np.copy(particle.position)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(new_position)):<br>        <span class="hljs-keyword">if</span> new_velocity[i] == <span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 找到全局最佳位置中的当前城市位置</span><br>            index = np.where(new_position == global_best_position[i])[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>            <span class="hljs-comment"># 交换位置</span><br>            new_position[i], new_position[index] = new_position[index], new_position[i]<br>    <br>    <span class="hljs-comment"># 计算新位置的成本</span><br>    cost = calculate_cost(new_position, distance_matrix)<br>    <br>    <span class="hljs-comment"># 更新个人最佳位置</span><br>    <span class="hljs-keyword">if</span> cost &lt; particle.best_cost:<br>        particle.best_position = new_position<br>        particle.best_cost = cost<br><br>    <span class="hljs-comment"># 更新粒子</span><br>    particle.position = new_position<br>    particle.velocity = new_velocity<br><br><span class="hljs-comment"># 粒子群优化算法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">particle_swarm_optimization</span>(<span class="hljs-params">distance_matrix, num_particles=<span class="hljs-number">10</span>, max_iterations=<span class="hljs-number">100</span></span>):<br>    num_cities = distance_matrix.shape[<span class="hljs-number">0</span>]<br>    particles = [Particle(num_cities) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_particles)]<br>    global_best_cost = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>    global_best_position = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_iterations):<br>        <span class="hljs-keyword">for</span> particle <span class="hljs-keyword">in</span> particles:<br>            cost = calculate_cost(particle.position, distance_matrix)<br>            <span class="hljs-keyword">if</span> cost &lt; particle.best_cost:<br>                particle.best_cost = cost<br>                particle.best_position = particle.position<br>            <span class="hljs-keyword">if</span> cost &lt; global_best_cost:<br>                global_best_cost = cost<br>                global_best_position = particle.position<br><br>        <span class="hljs-keyword">for</span> particle <span class="hljs-keyword">in</span> particles:<br>            update_particle(particle, global_best_position, distance_matrix)<br><br>    <span class="hljs-keyword">return</span> global_best_position, global_best_cost<br><br><span class="hljs-comment"># 定义距离矩阵</span><br>distance_matrix = np.array([<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>],<br>    [<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>    [<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>],<br>    [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>]<br>])<br><br><span class="hljs-comment"># 执行PSO</span><br>best_path, best_cost = particle_swarm_optimization(distance_matrix)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最短路径长度:&quot;</span>, best_cost)  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最短路径:&quot;</span>, best_path,)<br></code></pre></td></tr></table></figure><h3 id="3-2-输出结果">3.2  输出结果</h3><p><img src="/img/image-20240507203030570.png" alt=""></p><h2 id="4-GA解决TSP">4  GA解决TSP</h2><p>遗传算法是一种基于自然选择和遗传学原理的优化算法，它模拟了自然界中的进化过程。遗传算法的基本原理是通过不断地交叉和变异来生成新的解，并使用适应度函数来评估每个解的质量。在遗传算法中，解被表示为一个染色体，其中每个基因表示一个决策变量。通过不断迭代，遗传算法可以找到最优解。</p><p>对于TSP问题，遗传算法可以被用来寻找最短的路径。在遗传算法中，我们将问题表示为一个染色体，其中每个基因表示一个城市。我们使用交叉和变异操作来生成新的染色体，并使用适应度函数来评估每个染色体的质量。在TSP问题中，适应度函数可以是路径长度。通过不断迭代，我们可以找到最短的路径。</p><p>具体来说，遗传算法可以通过以下步骤来解决TSP问题：</p><ol><li>初始化种群：随机生成一组初始解，每个解表示一个染色体。</li><li>评估适应度：使用适应度函数来评估每个染色体的质量，适应度函数可以是路径长度。</li><li>选择操作：使用选择操作来选择优秀的染色体，以便它们可以被用来生成下一代。</li><li>交叉操作：使用交叉操作来生成新的染色体，以便它们可以被用来生成下一代。</li><li>变异操作：使用变异操作来引入新的基因，以便它们可以被用来生成下一代。</li><li>重复步骤5，直到达到停止条件。</li><li>输出最优解：输出适应度最高的染色体作为最优解。</li></ol><h3 id="4-1-Python编程实现">4.1  Python编程实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> matplotlib.pylab <span class="hljs-keyword">import</span> mpl<br> <br><span class="hljs-comment"># 添加这条可以让图形显示中文，字体显示为黑体</span><br>mpl.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]<br> <br> <br> <br><span class="hljs-comment"># 适应度的计算</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calFitness</span>(<span class="hljs-params">line, dis_matrix</span>):<br>    <span class="hljs-comment"># 贪婪策略得到距离矩阵（解码过程）</span><br>    <span class="hljs-comment"># 计算路径距离（评价函数）</span><br>    dis_sum = <span class="hljs-number">0</span>  <span class="hljs-comment"># 路线距离</span><br>    dis = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(line)):<br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(line) - <span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 依次计录一个数以及下一个数的距离，存入城市间的距离矩阵</span><br>            dis = dis_matrix.loc[line[i], line[i + <span class="hljs-number">1</span>]]<br>            dis_sum = dis_sum + dis<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 最后一个数，无下一个数的情况</span><br>            dis = dis_matrix.loc[line[i], line[<span class="hljs-number">0</span>]]<br>            dis_sum = dis_sum + dis<br>    <span class="hljs-comment"># 返回城市间的路线距离矩阵</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">round</span>(dis_sum, <span class="hljs-number">1</span>)<br> <br> <br><span class="hljs-comment"># 联赛选择算子</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tournament_select</span>(<span class="hljs-params">pops, popsize, fits, tournament_size</span>):<br>    new_pops, new_fits = [], []<br>    <span class="hljs-comment"># 步骤1 从群体中随机选择M个个体，计算每个个体的目标函数值</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(new_pops) &lt; <span class="hljs-built_in">len</span>(pops):<br>        tournament_list = random.sample(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, popsize), tournament_size)<br>        tournament_fit = [fits[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tournament_list]<br>        <span class="hljs-comment"># 转化为df方便索引</span><br>        tournament_df = pd.DataFrame \<br>            ([tournament_list, tournament_fit]).transpose().sort_values(by=<span class="hljs-number">1</span>).reset_index(drop=<span class="hljs-literal">True</span>)<br>        <span class="hljs-comment"># 步骤2 根据每个个体的目标函数值，计算其适应度</span><br>        fit = tournament_df.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>        pop = pops[<span class="hljs-built_in">int</span>(tournament_df.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])]<br>        <span class="hljs-comment"># 步骤3 选择适应度最大的个体</span><br>        new_pops.append(pop)<br>        new_fits.append(fit)<br>    <span class="hljs-keyword">return</span> new_pops, new_fits<br> <br> <br><span class="hljs-comment"># 交叉算子</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">crossover</span>(<span class="hljs-params">popsize, parent1_pops, parent2_pops, pc</span>):<br>    child_pops = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(popsize):<br>        <span class="hljs-comment"># 初始化</span><br>        child = [<span class="hljs-literal">None</span>] * <span class="hljs-built_in">len</span>(parent1_pops[i])<br>        parent1 = parent1_pops[i]<br>        parent2 = parent2_pops[i]<br>        <span class="hljs-keyword">if</span> random.random() &gt;= pc:<br>            child = parent1.copy()  <span class="hljs-comment"># 随机生成一个（或者随机保留父代中的一个）</span><br>            random.shuffle(child)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># parent1</span><br>            start_pos = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(parent1) - <span class="hljs-number">1</span>)<br>            end_pos = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(parent1) - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span> start_pos &gt; end_pos:<br>                tem_pop = start_pos<br>                start_pos = end_pos<br>                end_pos = tem_pop<br>            child[start_pos:end_pos + <span class="hljs-number">1</span>] = parent1[start_pos:end_pos + <span class="hljs-number">1</span>].copy()<br>            <span class="hljs-comment"># parent2 -&gt; child</span><br>            list1 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(end_pos + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(parent2)))<br>            list2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, start_pos))<br>            list_index = list1 + list2<br>            j = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list_index:<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(parent2)):<br>                    <span class="hljs-keyword">if</span> parent2[j] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> child:<br>                        child[i] = parent2[j]<br>                        <span class="hljs-keyword">break</span><br>        child_pops.append(child)<br>    <span class="hljs-keyword">return</span> child_pops<br> <br> <br><span class="hljs-comment"># 变异操作</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mutate</span>(<span class="hljs-params">pops, pm</span>):<br>    pops_mutate = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(pops)):<br>        pop = pops[i].copy()<br>        <span class="hljs-comment"># 随机多次成对变异</span><br>        <span class="hljs-comment"># 随机选出两个位置进行交换</span><br>        t = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> count &lt; t:<br>            <span class="hljs-keyword">if</span> random.random() &lt; pm:<br>                mut_pos1 = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(pop) - <span class="hljs-number">1</span>)<br>                mut_pos2 = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(pop) - <span class="hljs-number">1</span>)<br>                <span class="hljs-comment">#如果不相等则进行取反的操作，这里使用交换</span><br>                <span class="hljs-keyword">if</span> mut_pos1 != mut_pos2:<br>                    tem = pop[mut_pos1]<br>                    pop[mut_pos1] = pop[mut_pos2]<br>                    pop[mut_pos2] = tem<br>            pops_mutate.append(pop)<br>            count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> pops_mutate<br> <br> <br><span class="hljs-comment"># 画路径图</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_path</span>(<span class="hljs-params">line, CityCoordinates</span>):<br>    x, y = [], []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> line:<br>        Coordinate = CityCoordinates[i]<br>        x.append(Coordinate[<span class="hljs-number">0</span>])<br>        y.append(Coordinate[<span class="hljs-number">1</span>])<br>    x.append(x[<span class="hljs-number">0</span>])<br>    y.append(y[<span class="hljs-number">0</span>])<br>    plt.plot(x, y, <span class="hljs-string">&#x27;r-&#x27;</span>, color=<span class="hljs-string">&#x27;#FF3030&#x27;</span>, alpha=<span class="hljs-number">0.8</span>, linewidth=<span class="hljs-number">2.2</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.show()<br> <br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 参数</span><br>    CityNum = <span class="hljs-number">20</span>  <span class="hljs-comment"># 城市数量</span><br>    MinCoordinate = <span class="hljs-number">0</span>  <span class="hljs-comment"># 二维坐标最小值</span><br>    MaxCoordinate = <span class="hljs-number">101</span>  <span class="hljs-comment"># 二维坐标最大值</span><br>    <span class="hljs-comment"># GA参数</span><br>    generation = <span class="hljs-number">100</span> <span class="hljs-comment"># 迭代次数</span><br>    popsize = <span class="hljs-number">100</span>  <span class="hljs-comment"># 种群大小</span><br>    tournament_size = <span class="hljs-number">5</span>  <span class="hljs-comment"># 锦标赛小组大小</span><br>    pc = <span class="hljs-number">0.95</span>  <span class="hljs-comment"># 交叉概率</span><br>    pm = <span class="hljs-number">0.1</span>  <span class="hljs-comment"># 变异概率</span><br> <br>    <span class="hljs-comment"># 随机生成城市的坐标,城市序号为0,1,2,3...直到CityNum的数目20</span><br>    CityCoordinates = \<br>        [(random.randint(MinCoordinate, MaxCoordinate), random.randint(MinCoordinate, MaxCoordinate)) <span class="hljs-keyword">for</span><br>         i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(CityNum)]<br>    <span class="hljs-comment"># 计算城市之间的距离</span><br>    dis_matrix = \<br>        pd.DataFrame(data=<span class="hljs-literal">None</span>, columns=<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(CityCoordinates)), index=<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(CityCoordinates)))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(CityCoordinates)):<br>        xi, yi = CityCoordinates[i][<span class="hljs-number">0</span>], CityCoordinates[i][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(CityCoordinates)):<br>            xj, yj = CityCoordinates[j][<span class="hljs-number">0</span>], CityCoordinates[j][<span class="hljs-number">1</span>]<br>            dis_matrix.iloc[i, j] = <span class="hljs-built_in">round</span>(math.sqrt((xi - xj) ** <span class="hljs-number">2</span> + (yi - yj) ** <span class="hljs-number">2</span>), <span class="hljs-number">2</span>)<br> <br>    iteration = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 初始化,随机构造</span><br>    pops = \<br>        [random.sample([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(CityCoordinates)))], <span class="hljs-built_in">len</span>(CityCoordinates)) <span class="hljs-keyword">for</span><br>         j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(popsize)]<br>    <span class="hljs-comment">#画出随机得到的城市连接图</span><br>    draw_path(pops[i], CityCoordinates)<br>    <span class="hljs-comment"># 计算适应度</span><br>    fits = [<span class="hljs-literal">None</span>] * popsize<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(popsize):<br>        fits[i] = calFitness(pops[i], dis_matrix)<br>    <span class="hljs-comment"># 保留当前最优,最小的fits为最优解</span><br>    best_fit = <span class="hljs-built_in">min</span>(fits)<br>    best_pop = pops[fits.index(best_fit)]<br> <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;初代最优值 %.1f&#x27;</span> % (best_fit))<br>    best_fit_list = []<br>    best_fit_list.append(best_fit)<br> <br>    <span class="hljs-keyword">while</span> iteration &lt;= generation:<br>        <span class="hljs-comment"># 锦标赛赛选择</span><br>        pop1, fits1 = tournament_select(pops, popsize, fits, tournament_size)<br>        pop2, fits2 = tournament_select(pops, popsize, fits, tournament_size)<br>        <span class="hljs-comment"># 交叉</span><br>        child_pops = crossover(popsize, pop1, pop2, pc)<br>        <span class="hljs-comment"># 变异</span><br>        child_pops = mutate(child_pops, pm)<br>        <span class="hljs-comment"># 计算子代适应度</span><br>        child_fits = [<span class="hljs-literal">None</span>] * popsize<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(popsize):<br>            child_fits[i] = calFitness(child_pops[i], dis_matrix)<br>            <span class="hljs-comment"># 一对一生存者竞争</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(popsize):<br>            <span class="hljs-keyword">if</span> fits[i] &gt; child_fits[i]:<br>                fits[i] = child_fits[i]<br>                pops[i] = child_pops[i]<br> <br>        <span class="hljs-keyword">if</span> best_fit &gt; <span class="hljs-built_in">min</span>(fits):<br>            best_fit = <span class="hljs-built_in">min</span>(fits)<br>            best_pop = pops[fits.index(best_fit)]<br> <br>        best_fit_list.append(best_fit)<br> <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第%d代最优值 %.1f&#x27;</span> % (iteration, best_fit))<br>        iteration += <span class="hljs-number">1</span><br> <br>    <span class="hljs-comment"># 路径顺序</span><br>    <span class="hljs-built_in">print</span>(best_pop)<br> <br>    draw_path(best_pop, CityCoordinates)<br></code></pre></td></tr></table></figure><h3 id="4-2-输出结果">4.2  输出结果</h3><p>仅展示前10次迭代以及后10次迭代：</p><p><img src="/img/image-20240507203358610.png" alt=""></p><p><img src="/img/image-20240507203323057.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>人工智能与专家系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HW</tag>
      
      <tag>Python</tag>
      
      <tag>启发式算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DUT人工智能与专家系统_HW1</title>
    <link href="/2024/07/08/DUT%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F_HW1/"/>
    <url>/2024/07/08/DUT%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F_HW1/</url>
    
    <content type="html"><![CDATA[<h3 id="1-采用广度优先搜索-BFS-、深度优先搜索-DFS-编程求解八数码问题（初始状态允许任意），找出一种从初始状态到目标状态移动步数最少的步骤。">1  采用广度优先搜索(BFS)、深度优先搜索(DFS)编程求解八数码问题（初始状态允许任意），找出一种从初始状态到目标状态移动步数最少的步骤。</h3><p>八数码难题是一种经典的拼图游戏，也称为九宫格问题。它的目标是将一个 3x3 的方格拼图按照指定的顺序排列。每个方格上都有一个数字，其中一个方格为空，可以与相邻的方格交换位置。例如，以下是一个八数码难题的初始状态和目标状态：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">初始状态：   目标状态：<br>2<span class="hljs-number"> 8 </span>3       <span class="hljs-number"> 1 </span>2 3<br>1<span class="hljs-number"> 0 </span>4   -&gt;  <span class="hljs-number"> 8 </span>0 4<br>7<span class="hljs-number"> 6 </span>5       <span class="hljs-number"> 7 </span>6<span class="hljs-number"> 5 </span><br></code></pre></td></tr></table></figure><p>八数码难题最早出现在19世纪末期，当时它被称为“九宫格问题”，是由美国的一位数学家Sam Loyd发明的。他将数字1到8排列在一个3x3的方格中，留下一个空格，要求将数字重新排列，使得数字从左到右、从上到下依次排列。这个问题在当时引起了很大的轰动，成为了一种流行的智力游戏。</p><p>八数码难题在计算机科学中也有着广泛的应用。它是人工智能领域中的一个经典问题，可以用来测试搜索算法的性能和效率。八数码难题也被用来研究人类的思维过程和决策行为。此外，八数码难题还被应用于密码学和安全领域，例如用于生成随机数列和加密算法。</p><p>八数码难题的解法可以通过搜索算法来实现。搜索算法是一种通过遍历状态空间来寻找解决问题的方法。在八数码难题中，状态空间是所有可能的状态的集合，每个状态表示为一个3x3的矩阵。搜索算法可以通过遍历状态空间来找到从初始状态到目标状态的路径，即解决方案。</p><p>常用的搜索算法包括深度优先算法、广度优先算法、A*算法等。这些算法在八数码难题中的表现不同，具有不同的优缺点。例如，深度优先算法可以实现内存占用小，但可能会陷入局部最优解；广度优先算法可以保证找到最优解，但需要更多的内存空间。</p><p>除了搜索算法，还有一些其他的解法可以用来解决八数码难题，例如启发式搜索、模拟退火等。这些方法可以通过引入启发式函数、随机化等技术来提高搜索效率和解决复杂问题。</p><p>总之，八数码难题是一个经典的拼图游戏，具有广泛的应用价值。通过搜索算法和其他解法，我们可以找到从初始状态到目标状态的路径，解决这个问题。在计算机科学和人工智能领域，八数码难题是一个重要的研究对象，可以帮助我们更好地理解和应用搜索算法、人工智能和机器学习等技术。</p><h4 id="1-1-BSF求解八数码问题">1.1  BSF求解八数码问题</h4><p>广度优先搜索 （BFS） 算法，从它的名字“广度”开始，通过节点的外边缘发现节点的所有邻居，然后通过它们的外边缘发现前面提到的邻居的未访问邻居，依此类推，直到访问从原始源访问的所有节点（如果还有剩余的未访问节点，我们可以继续并采用另一个原始源，依此类推）。这就是为什么如果边的权重是均匀的，它可以用来找到从一个节点（原始源）到另一个节点的最短路径（如果有的话）。</p><p>在八数码难题中，广度优先算法会从初始状态开始，先将所有与初始状态相邻的状态加入队列，然后遍历这些状态相邻的状态，以此类推，直到找到目标状态或者遍历完整个状态空间。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># BSF</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-comment"># 定义目标状态</span><br>goal_state = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 0代表空格</span><br><span class="hljs-comment"># 计算当前状态的可行动作</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_actions</span>(<span class="hljs-params">state</span>):<br>    actions = []<br>    empty_index = state.index(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> empty_index % <span class="hljs-number">3</span> &gt; <span class="hljs-number">0</span>:<br>        actions.append(<span class="hljs-string">&#x27;left&#x27;</span>)<br>    <span class="hljs-keyword">if</span> empty_index % <span class="hljs-number">3</span> &lt; <span class="hljs-number">2</span>:<br>        actions.append(<span class="hljs-string">&#x27;right&#x27;</span>)<br>    <span class="hljs-keyword">if</span> empty_index &gt;= <span class="hljs-number">3</span>:<br>        actions.append(<span class="hljs-string">&#x27;up&#x27;</span>)<br>    <span class="hljs-keyword">if</span> empty_index &lt; <span class="hljs-number">6</span>:<br>        actions.append(<span class="hljs-string">&#x27;down&#x27;</span>)<br>    <span class="hljs-keyword">return</span> actions<br><span class="hljs-comment"># 执行动作，生成新状态</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">state, action</span>):<br>    new_state = state[:]<br>    empty_index = new_state.index(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> action == <span class="hljs-string">&#x27;left&#x27;</span>:<br>        new_state[empty_index], new_state[empty_index - <span class="hljs-number">1</span>] = new_state[empty_index - <span class="hljs-number">1</span>], new_state[empty_index]<br>    <span class="hljs-keyword">elif</span> action == <span class="hljs-string">&#x27;right&#x27;</span>:<br>        new_state[empty_index], new_state[empty_index + <span class="hljs-number">1</span>] = new_state[empty_index + <span class="hljs-number">1</span>], new_state[empty_index]<br>    <span class="hljs-keyword">elif</span> action == <span class="hljs-string">&#x27;up&#x27;</span>:<br>        new_state[empty_index], new_state[empty_index - <span class="hljs-number">3</span>] = new_state[empty_index - <span class="hljs-number">3</span>], new_state[empty_index]<br>    <span class="hljs-keyword">elif</span> action == <span class="hljs-string">&#x27;down&#x27;</span>:<br>        new_state[empty_index], new_state[empty_index + <span class="hljs-number">3</span>] = new_state[empty_index + <span class="hljs-number">3</span>], new_state[empty_index]<br>    <span class="hljs-keyword">return</span> new_state<br><span class="hljs-comment"># 广度优先搜索</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bfs</span>(<span class="hljs-params">initial_state</span>):<br>    queue = deque([(initial_state, [])])<br>    visited = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">while</span> queue:<br>        state, path = queue.popleft()<br>        visited.add(<span class="hljs-built_in">tuple</span>(state))<br>        <span class="hljs-keyword">if</span> state == goal_state:<br>            <span class="hljs-keyword">return</span> path<br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> get_actions(state):<br>            new_state = move(state, action)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">tuple</span>(new_state) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                queue.append((new_state, path + [action]))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    initial_state = [<span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]  <span class="hljs-comment"># 初始状态</span><br>    solution = bfs(initial_state)<br>    <span class="hljs-keyword">if</span> solution:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Solution found in&quot;</span>, <span class="hljs-built_in">len</span>(solution), <span class="hljs-string">&quot;steps:&quot;</span>, solution)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No solution found.&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="/img/image-20240412205955577.png" alt=""></p><h4 id="1-2-DSF求解八数码问题">1.2  DSF求解八数码问题</h4><p>深度优先搜索 （DFS） 算法，从其名称“深度”开始，通过其外边缘发现最近发现的节点 x 的未访问邻居。如果节点 x 没有未访问的邻居，则算法回溯以发现节点 x 的节点的未访问邻居（通过其外部边缘），依此类推，直到访问从原始源访问的所有节点（如果还有剩余的未访问节点，我们可以继续并采用另一个原始源，依此类推）。</p><p>在八数码难题中，深度优先算法会从初始状态开始，选择一个数字，将其与空格交换位置，然后继续向下搜索，直到找到目标状态或者无法继续为止。如果无法继续，算法会回溯到上一个节点，继续搜索其他方向。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># DSF</span><br><span class="hljs-comment"># 定义目标状态</span><br>goal_state = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 0代表空格</span><br><span class="hljs-comment"># 计算当前状态的可行动作</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_actions</span>(<span class="hljs-params">state</span>):<br>    actions = []<br>    empty_index = state.index(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> empty_index % <span class="hljs-number">3</span> &gt; <span class="hljs-number">0</span>:<br>        actions.append(<span class="hljs-string">&#x27;left&#x27;</span>)<br>    <span class="hljs-keyword">if</span> empty_index % <span class="hljs-number">3</span> &lt; <span class="hljs-number">2</span>:<br>        actions.append(<span class="hljs-string">&#x27;right&#x27;</span>)<br>    <span class="hljs-keyword">if</span> empty_index &gt;= <span class="hljs-number">3</span>:<br>        actions.append(<span class="hljs-string">&#x27;up&#x27;</span>)<br>    <span class="hljs-keyword">if</span> empty_index &lt; <span class="hljs-number">6</span>:<br>        actions.append(<span class="hljs-string">&#x27;down&#x27;</span>)<br>    <span class="hljs-keyword">return</span> actions<br><span class="hljs-comment"># 执行动作，生成新状态</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">state, action</span>):<br>    new_state = state[:]<br>    empty_index = new_state.index(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> action == <span class="hljs-string">&#x27;left&#x27;</span>:<br>        new_state[empty_index], new_state[empty_index - <span class="hljs-number">1</span>] = new_state[empty_index - <span class="hljs-number">1</span>], new_state[empty_index]<br>    <span class="hljs-keyword">elif</span> action == <span class="hljs-string">&#x27;right&#x27;</span>:<br>        new_state[empty_index], new_state[empty_index + <span class="hljs-number">1</span>] = new_state[empty_index + <span class="hljs-number">1</span>], new_state[empty_index]<br>    <span class="hljs-keyword">elif</span> action == <span class="hljs-string">&#x27;up&#x27;</span>:<br>        new_state[empty_index], new_state[empty_index - <span class="hljs-number">3</span>] = new_state[empty_index - <span class="hljs-number">3</span>], new_state[empty_index]<br>    <span class="hljs-keyword">elif</span> action == <span class="hljs-string">&#x27;down&#x27;</span>:<br>        new_state[empty_index], new_state[empty_index + <span class="hljs-number">3</span>] = new_state[empty_index + <span class="hljs-number">3</span>], new_state[empty_index]<br>    <span class="hljs-keyword">return</span> new_state<br><span class="hljs-comment"># 深度优先搜索</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">state, path, visited, depth_limit</span>):<br>    <span class="hljs-keyword">if</span> state == goal_state:<br>        <span class="hljs-keyword">return</span> path<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) &gt;= depth_limit:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    visited.add(<span class="hljs-built_in">tuple</span>(state))<br>    <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> get_actions(state):<br>        new_state = move(state, action)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">tuple</span>(new_state) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>            result = dfs(new_state, path + [action], visited, depth_limit)<br>            <span class="hljs-keyword">if</span> result:<br>                <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    initial_state = [<span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]  <span class="hljs-comment"># 初始状态</span><br>    max_depth = <span class="hljs-number">30</span>  <span class="hljs-comment"># 深度限制</span><br>    solution = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> depth <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, max_depth + <span class="hljs-number">1</span>):<br>        visited = <span class="hljs-built_in">set</span>()<br>        solution = dfs(initial_state, [], visited, depth)<br>        <span class="hljs-keyword">if</span> solution:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> solution:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Solution found in&quot;</span>, <span class="hljs-built_in">len</span>(solution), <span class="hljs-string">&quot;steps:&quot;</span>, solution)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No solution found within depth limit.&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="/img/image-20240412210156769.png" alt=""></p><h3 id="2-分啤酒问题-状态空间搜索问题-现有8升、5升、3升的容器各一个，均无任何度量标记，其中8升的容器装满啤酒，其他两个为空。要求用上述容器倒来倒去，分成两份4升的啤酒。">2  分啤酒问题(状态空间搜索问题) 现有8升、5升、3升的容器各一个，均无任何度量标记，其中8升的容器装满啤酒，其他两个为空。要求用上述容器倒来倒去，分成两份4升的啤酒。</h3><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义目标状态</span><br>goal_state = (<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 获取当前状态可行的倒酒操作</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_actions</span>(<span class="hljs-params">state</span>):<br>    actions = []<br>    x, y, z = state<br>    <span class="hljs-comment"># 倒酒操作：</span><br>    <span class="hljs-comment"># 1. 从x到y</span><br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y &lt; <span class="hljs-number">5</span>:<br>        actions.append((<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>))<br>    <span class="hljs-comment"># 2. 从x到z</span><br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> z &lt; <span class="hljs-number">3</span>:<br>        actions.append((<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>))<br>    <span class="hljs-comment"># 3. 从y到x</span><br>    <span class="hljs-keyword">if</span> y &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> x &lt; <span class="hljs-number">8</span>:<br>        actions.append((<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>))<br>    <span class="hljs-comment"># 4. 从y到z</span><br>    <span class="hljs-keyword">if</span> y &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> z &lt; <span class="hljs-number">3</span>:<br>        actions.append((<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>))<br>    <span class="hljs-comment"># 5. 从z到x</span><br>    <span class="hljs-keyword">if</span> z &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> x &lt; <span class="hljs-number">8</span>:<br>        actions.append((<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>))<br>    <span class="hljs-comment"># 6. 从z到y</span><br>    <span class="hljs-keyword">if</span> z &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y &lt; <span class="hljs-number">5</span>:<br>        actions.append((<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>))<br>    <span class="hljs-keyword">return</span> actions<br><span class="hljs-comment"># 执行倒酒操作，生成新状态</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pour</span>(<span class="hljs-params">state, action</span>):<br>    x, y, z = state<br>    from_vessel, to_vessel = action<br>    <span class="hljs-keyword">if</span> from_vessel == <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">and</span> to_vessel == <span class="hljs-string">&#x27;y&#x27;</span>:<br>        amount = <span class="hljs-built_in">min</span>(x, <span class="hljs-number">5</span> - y)<br>        <span class="hljs-keyword">return</span> (x - amount, y + amount, z)<br>    <span class="hljs-keyword">elif</span> from_vessel == <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">and</span> to_vessel == <span class="hljs-string">&#x27;z&#x27;</span>:<br>        amount = <span class="hljs-built_in">min</span>(x, <span class="hljs-number">3</span> - z)<br>        <span class="hljs-keyword">return</span> (x - amount, y, z + amount)<br>    <span class="hljs-keyword">elif</span> from_vessel == <span class="hljs-string">&#x27;y&#x27;</span> <span class="hljs-keyword">and</span> to_vessel == <span class="hljs-string">&#x27;x&#x27;</span>:<br>        amount = <span class="hljs-built_in">min</span>(y, <span class="hljs-number">8</span> - x)<br>        <span class="hljs-keyword">return</span> (x + amount, y - amount, z)<br>    <span class="hljs-keyword">elif</span> from_vessel == <span class="hljs-string">&#x27;y&#x27;</span> <span class="hljs-keyword">and</span> to_vessel == <span class="hljs-string">&#x27;z&#x27;</span>:<br>        amount = <span class="hljs-built_in">min</span>(y, <span class="hljs-number">3</span> - z)<br>        <span class="hljs-keyword">return</span> (x, y - amount, z + amount)<br>    <span class="hljs-keyword">elif</span> from_vessel == <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-keyword">and</span> to_vessel == <span class="hljs-string">&#x27;x&#x27;</span>:<br>        amount = <span class="hljs-built_in">min</span>(z, <span class="hljs-number">8</span> - x)<br>        <span class="hljs-keyword">return</span> (x + amount, y, z - amount)<br>    <span class="hljs-keyword">elif</span> from_vessel == <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-keyword">and</span> to_vessel == <span class="hljs-string">&#x27;y&#x27;</span>:<br>        amount = <span class="hljs-built_in">min</span>(z, <span class="hljs-number">5</span> - y)<br>        <span class="hljs-keyword">return</span> (x, y + amount, z - amount)<br><span class="hljs-comment"># 深度优先搜索</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">state, path, visited</span>):<br>    <span class="hljs-keyword">if</span> state == goal_state:<br>        <span class="hljs-keyword">return</span> path<br>    visited.add(state)<br>    <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> get_actions(state):<br>        new_state = pour(state, action)<br>        <span class="hljs-keyword">if</span> new_state <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>            result = dfs(new_state, path + [action], visited)<br>            <span class="hljs-keyword">if</span> result:<br>                <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    initial_state = (<span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 初始状态（8升容器中装满）</span><br>    visited = <span class="hljs-built_in">set</span>()<br>    solution = dfs(initial_state, [], visited)<br>    <span class="hljs-keyword">if</span> solution:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Solution found in&quot;</span>, <span class="hljs-built_in">len</span>(solution), <span class="hljs-string">&quot;steps:&quot;</span>, solution)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No solution found.&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="/img/image-20240412211323876.png" alt=""></p><h3 id="3-传教士和野人过河问题-启发式搜索算法-：-有N个传教士和N个野人来到河边渡河，河岸有一条船，每次至多可供k人乘渡。问传教士为了安全起见，应规划摆渡方案，使得任何时刻，传教士和野人在一起时河两岸及船上的野人数目总是不超过传教士的数目-否则传教士有可能被野人吃掉-。求解传教士和野人从左岸全部摆渡到右岸的过程中，任何时刻传教士和野人在一起时，满足传教士数大于或等于野人数，并且两者人数之和小于k的摆渡方案。">3  传教士和野人过河问题(启发式搜索算法)： 有N个传教士和N个野人来到河边渡河，河岸有一条船，每次至多可供k人乘渡。问传教士为了安全起见，应规划摆渡方案，使得任何时刻，传教士和野人在一起时河两岸及船上的野人数目总是不超过传教士的数目(否则传教士有可能被野人吃掉)。求解传教士和野人从左岸全部摆渡到右岸的过程中，任何时刻传教士和野人在一起时，满足传教士数大于或等于野人数，并且两者人数之和小于k的摆渡方案。</h3><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, left_missionaries, left_cannibals, boat, right_missionaries, right_cannibals, parent=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-variable language_">self</span>.left_missionaries = left_missionaries  <span class="hljs-comment"># 左岸传教士数量</span><br>        <span class="hljs-variable language_">self</span>.left_cannibals = left_cannibals  <span class="hljs-comment"># 左岸野人数量</span><br>        <span class="hljs-variable language_">self</span>.boat = boat  <span class="hljs-comment"># 船的位置，&#x27;left&#x27;表示在左岸，&#x27;right&#x27;表示在右岸</span><br>        <span class="hljs-variable language_">self</span>.right_missionaries = right_missionaries  <span class="hljs-comment"># 右岸传教士数量</span><br>        <span class="hljs-variable language_">self</span>.right_cannibals = right_cannibals  <span class="hljs-comment"># 右岸野人数量</span><br>        <span class="hljs-variable language_">self</span>.parent = parent  <span class="hljs-comment"># 父状态</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_valid</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 判断状态是否合法，即各个岸上的传教士和野人数目是否符合规则</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.left_missionaries &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.left_cannibals &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.right_missionaries &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.right_cannibals &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.left_missionaries &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.left_cannibals &gt; <span class="hljs-variable language_">self</span>.left_missionaries:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.right_missionaries &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.right_cannibals &gt; <span class="hljs-variable language_">self</span>.right_missionaries:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_goal</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 判断是否达到目标状态，即左岸没有传教士和野人</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.left_missionaries == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.left_cannibals == <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-comment"># 判断两个状态是否相等，用于集合去重</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.left_missionaries == other.left_missionaries <span class="hljs-keyword">and</span> \<br>               <span class="hljs-variable language_">self</span>.left_cannibals == other.left_cannibals <span class="hljs-keyword">and</span> \<br>               <span class="hljs-variable language_">self</span>.boat == other.boat <span class="hljs-keyword">and</span> \<br>               <span class="hljs-variable language_">self</span>.right_missionaries == other.right_missionaries <span class="hljs-keyword">and</span> \<br>               <span class="hljs-variable language_">self</span>.right_cannibals == other.right_cannibals<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 哈希函数，用于集合去重</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>((<span class="hljs-variable language_">self</span>.left_missionaries, <span class="hljs-variable language_">self</span>.left_cannibals, <span class="hljs-variable language_">self</span>.boat, <span class="hljs-variable language_">self</span>.right_missionaries, <span class="hljs-variable language_">self</span>.right_cannibals))<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># dummy implementation for A* algorithm</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_actions</span>(<span class="hljs-params">state, k</span>):<br>    <span class="hljs-comment"># 获取当前状态可行的动作列表</span><br>    actions = []<br>    <span class="hljs-keyword">if</span> state.boat == <span class="hljs-string">&#x27;left&#x27;</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; j &lt;= i:<br>                    actions.append((i - j, j, <span class="hljs-string">&#x27;right&#x27;</span>))  <span class="hljs-comment"># 从左岸到右岸，带走i-j个传教士和j个野人</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; j &lt;= i:<br>                    actions.append((j, i - j, <span class="hljs-string">&#x27;left&#x27;</span>))  <span class="hljs-comment"># 从右岸到左岸，带走j个传教士和i-j个野人</span><br>    <span class="hljs-keyword">return</span> actions<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">transition</span>(<span class="hljs-params">state, action</span>):<br>    <span class="hljs-comment"># 根据动作执行状态转移</span><br>    <span class="hljs-keyword">if</span> state.boat == <span class="hljs-string">&#x27;left&#x27;</span>:<br>        <span class="hljs-keyword">return</span> State(state.left_missionaries - action[<span class="hljs-number">0</span>], state.left_cannibals - action[<span class="hljs-number">1</span>], action[<span class="hljs-number">2</span>],<br>                     state.right_missionaries + action[<span class="hljs-number">0</span>], state.right_cannibals + action[<span class="hljs-number">1</span>], state)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> State(state.left_missionaries + action[<span class="hljs-number">0</span>], state.left_cannibals + action[<span class="hljs-number">1</span>], action[<span class="hljs-number">2</span>],<br>                     state.right_missionaries - action[<span class="hljs-number">0</span>], state.right_cannibals - action[<span class="hljs-number">1</span>], state)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">heuristic</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-comment"># 启发式函数，用于估计当前状态到目标状态的距离</span><br>    <span class="hljs-keyword">return</span> state.left_missionaries + state.left_cannibals<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">astar</span>(<span class="hljs-params">start_state, k</span>):<br>    open_list = []  <span class="hljs-comment"># 开放列表</span><br>    closed_set = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 关闭列表，用于记录已经访问过的状态</span><br>    heapq.heappush(open_list, (heuristic(start_state), start_state))  <span class="hljs-comment"># 将初始状态加入开放列表</span><br>    <span class="hljs-keyword">while</span> open_list:<br>        _, current_state = heapq.heappop(open_list)  <span class="hljs-comment"># 从开放列表中取出启发式评估值最小的状态</span><br>        <span class="hljs-keyword">if</span> current_state.is_goal():  <span class="hljs-comment"># 如果当前状态是目标状态，返回当前状态</span><br>            <span class="hljs-keyword">return</span> current_state<br>        closed_set.add(current_state)  <span class="hljs-comment"># 将当前状态加入关闭列表</span><br>        <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> get_actions(current_state, k):  <span class="hljs-comment"># 获取当前状态可行的动作列表</span><br>            new_state = transition(current_state, action)  <span class="hljs-comment"># 根据动作执行状态转移</span><br>            <span class="hljs-keyword">if</span> new_state.is_valid() <span class="hljs-keyword">and</span> new_state <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> closed_set:  <span class="hljs-comment"># 如果新状态合法且未被访问过</span><br>                heapq.heappush(open_list, (heuristic(new_state), new_state))  <span class="hljs-comment"># 将新状态加入开放列表</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 如果找不到解，则返回None</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_solution</span>(<span class="hljs-params">solution</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> solution:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No solution found.&quot;</span>)  <span class="hljs-comment"># 如果找不到解，输出提示信息</span><br>        <span class="hljs-keyword">return</span><br>    path = []<br>    <span class="hljs-keyword">while</span> solution:<br>        path.append(solution)<br>        solution = solution.parent<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(path) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):  <span class="hljs-comment"># 从后向前遍历路径，打印每个状态</span><br>        state = path[i]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Left: <span class="hljs-subst">&#123;state.left_missionaries&#125;</span> missionaries, <span class="hljs-subst">&#123;state.left_cannibals&#125;</span> cannibals&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Boat: <span class="hljs-subst">&#123;<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-keyword">if</span> state.boat == <span class="hljs-string">&quot;left&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;right&quot;</span>&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Right: <span class="hljs-subst">&#123;state.right_missionaries&#125;</span> missionaries, <span class="hljs-subst">&#123;state.right_cannibals&#125;</span> cannibals&#x27;</span>)<br>        <span class="hljs-built_in">print</span>()<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 设置初始状态和船的容量</span><br>    start_state = State(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;left&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    k = <span class="hljs-number">3</span><br>    <span class="hljs-comment"># 使用A*算法求解</span><br>    solution = astar(start_state, k)<br>    <span class="hljs-comment"># 打印解决方案</span><br>    print_solution(solution)<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="/img/image-20240412211546646.png" alt=""></p><h3 id="4-人机对战五子棋游戏-博弈搜索α-β剪枝策略-五子棋的专用棋盘为15路-15╳15-，盘面上横竖各15条、平行线、纵横、线路为黑色，构成225个交叉点。游戏规则：先手无限制，在对局开始时，先由执黑棋的一方将一枚棋子落在天元点上，然后由执白棋的一方在黑棋周围的交叉点上落子。此后，由执黑棋的一方在以天元为中心的25个交叉点的范围内，下盘面的第三手棋。然后由执白棋的一方应手，即下盘面的第四手棋。以后如此轮流落子，直到某一方首先在棋盘的直线、横线或斜线上形成连续5子或5子以上，则该方就算获胜。">4  人机对战五子棋游戏(博弈搜索α-β剪枝策略) :五子棋的专用棋盘为15路(15╳15)，盘面上横竖各15条、平行线、纵横、线路为黑色，构成225个交叉点。游戏规则：先手无限制，在对局开始时，先由执黑棋的一方将一枚棋子落在天元点上，然后由执白棋的一方在黑棋周围的交叉点上落子。此后，由执黑棋的一方在以天元为中心的25个交叉点的范围内，下盘面的第三手棋。然后由执白棋的一方应手，即下盘面的第四手棋。以后如此轮流落子，直到某一方首先在棋盘的直线、横线或斜线上形成连续5子或5子以上，则该方就算获胜。</h3><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义棋盘大小</span><br>BOARD_SIZE = <span class="hljs-number">15</span><br><br><span class="hljs-comment"># 初始化棋盘</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_board</span>():<br>    <span class="hljs-keyword">return</span> np.zeros((BOARD_SIZE, BOARD_SIZE), dtype=<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># 打印棋盘</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_board</span>(<span class="hljs-params">board</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  &quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BOARD_SIZE):<br>        <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(board):<br>        <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BOARD_SIZE):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;●&quot;</span> <span class="hljs-keyword">if</span> row[j] == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;○&quot;</span> <span class="hljs-keyword">if</span> row[j] == -<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;.&quot;</span>, end=<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-built_in">print</span>()<br><br><span class="hljs-comment"># 检查是否有胜者</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_win</span>(<span class="hljs-params">board, player</span>):<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BOARD_SIZE):<br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BOARD_SIZE):<br>            <span class="hljs-comment"># 检查横向</span><br>            <span class="hljs-keyword">if</span> x + <span class="hljs-number">4</span> &lt; BOARD_SIZE <span class="hljs-keyword">and</span> <span class="hljs-built_in">all</span>(board[x+i][y] == player <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 检查纵向</span><br>            <span class="hljs-keyword">if</span> y + <span class="hljs-number">4</span> &lt; BOARD_SIZE <span class="hljs-keyword">and</span> <span class="hljs-built_in">all</span>(board[x][y+i] == player <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 检查主对角线</span><br>            <span class="hljs-keyword">if</span> x + <span class="hljs-number">4</span> &lt; BOARD_SIZE <span class="hljs-keyword">and</span> y + <span class="hljs-number">4</span> &lt; BOARD_SIZE <span class="hljs-keyword">and</span> <span class="hljs-built_in">all</span>(board[x+i][y+i] == player <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-comment"># 检查副对角线</span><br>            <span class="hljs-keyword">if</span> x + <span class="hljs-number">4</span> &lt; BOARD_SIZE <span class="hljs-keyword">and</span> y - <span class="hljs-number">4</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">all</span>(board[x+i][y-i] == player <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 检查是否可以在指定位置落子</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_valid_move</span>(<span class="hljs-params">board, x, y</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= x &lt; BOARD_SIZE <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; BOARD_SIZE <span class="hljs-keyword">and</span> board[x][y] == <span class="hljs-number">0</span><br><br><span class="hljs-comment"># α-β剪枝</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">alpha_beta_search</span>(<span class="hljs-params">board, depth, player, alpha, beta, max_player</span>):<br>    <span class="hljs-keyword">if</span> depth == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> check_win(board, player):<br>        <span class="hljs-keyword">return</span> evaluate(board, player), <span class="hljs-literal">None</span><br><br>    best_score = <span class="hljs-literal">None</span><br>    best_move = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BOARD_SIZE):<br>        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BOARD_SIZE):<br>            <span class="hljs-keyword">if</span> is_valid_move(board, x, y):<br>                new_board = np.copy(board)<br>                new_board[x][y] = player<br>                score, _ = alpha_beta_search(new_board, depth - <span class="hljs-number">1</span>, -player, alpha, beta, max_player)<br>                <span class="hljs-keyword">if</span> player == max_player:<br>                    <span class="hljs-keyword">if</span> best_score <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> score &gt; best_score:<br>                        best_score = score<br>                        best_move = (x, y)<br>                    alpha = <span class="hljs-built_in">max</span>(alpha, score)<br>                    <span class="hljs-keyword">if</span> beta &lt;= alpha:<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> best_score <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> score &lt; best_score:<br>                        best_score = score<br>                        best_move = (x, y)<br>                    beta = <span class="hljs-built_in">min</span>(beta, score)<br>                    <span class="hljs-keyword">if</span> alpha &gt;= beta:<br>                        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> (best_score, best_move)<br><br><span class="hljs-comment"># 评估当前棋盘状态</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">board, player</span>):<br>    <span class="hljs-comment"># 评分规则可以根据实际情况进行调整</span><br>    <span class="hljs-comment"># 这里简单地给黑方和白方分别赋值为1和-1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> player == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 人机对战</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">play_game</span>():<br>    board = init_board()<br>    current_player = <span class="hljs-number">1</span>  <span class="hljs-comment"># 黑方先手</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> check_win(board, <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> check_win(board, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> current_player == <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;玩家的回合:&quot;</span>)<br>            x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入行和列（用空格分隔）：&quot;</span>).split())<br>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> is_valid_move(board, x, y):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;无效的落子位置，请重新输入.&quot;</span>)<br>                x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入行和列（用空格分隔）：&quot;</span>).split())<br>            board[x][y] = current_player<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前棋盘状态:&quot;</span>)<br>            print_board(board)<br>            <span class="hljs-keyword">if</span> check_win(board, current_player):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;恭喜，玩家获胜!&quot;</span>)<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算机的回合:&quot;</span>)<br>            _, best_move = alpha_beta_search(board, <span class="hljs-number">1</span>, -current_player, -<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>), <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>), current_player)<br>            x, y = best_move<br>            board[x][y] = current_player<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前棋盘状态:&quot;</span>)<br>            print_board(board)<br>            <span class="hljs-keyword">if</span> check_win(board, current_player):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;遗憾，计算机获胜!&quot;</span>)<br>                <span class="hljs-keyword">break</span><br>        current_player = -current_player<br><br><span class="hljs-comment"># 开始游戏</span><br>play_game()<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="/img/image-20240412211746788.png" alt=""></p><h3 id="5-求解八数码问题-启发式搜索）在3×3的方格棋盘上，摆放着1到8这八个数码，有1个方格是空的，其初始状态如图所示，要求对空格执行空格左移、空格右移、空格上移和空格下移这四个操作使得棋盘从初始状态到目标状态。目标：求出从初始状态到目标状态的最少步骤和路径（解法）">5  求解八数码问题(启发式搜索）在3×3的方格棋盘上，摆放着1到8这八个数码，有1个方格是空的，其初始状态如图所示，要求对空格执行空格左移、空格右移、空格上移和空格下移这四个操作使得棋盘从初始状态到目标状态。目标：求出从初始状态到目标状态的最少步骤和路径（解法）</h3><p><img src="/img/image-20240412212641148.png" alt=""></p><p>AStar算法是一种启发式搜索算法，它通过引入启发式函数来评估每个状态的价值。启发式函数是一个估计函数，用来估计从当前状态到目标状态的距离。AStar算法将启发式函数的估计值和已经走过的路径的代价相结合，得到每个状态的价值，从而选择最优的路径。</p><p>AStar算法的基本思想是：从初始状态开始，计算每个状态的价值，并选择价值最小的状态作为下一步的目标。在计算状态的价值时，A算法将已经走过的路径的代价和启发式函数的估计值相结合，得到状态的总价值。具体地，A*算法使用以下公式计算状态的总价值：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = g(n) + h(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p><p>其中，f(n)表示状态n的总价值，g(n)表示从初始状态到状态n的代价，h(n)表示从状态n到目标状态的估计代价。</p><p>AStar算法通过遍历状态空间，计算每个状态的总价值，并选择总价值最小的状态作为下一步的目标。如果找到了目标状态，算法就停止搜索，输出解决方案。如果遍历完整个状态空间，仍然没有找到目标状态，算法就停止搜索，输出无解。</p><p>AStar算法解决八数码难题的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, state, parent=<span class="hljs-literal">None</span>, action=<span class="hljs-literal">None</span></span>):  <br>        <span class="hljs-variable language_">self</span>.state = state  <br>        <span class="hljs-variable language_">self</span>.parent = parent  <br>        <span class="hljs-variable language_">self</span>.action = action  <br>        <span class="hljs-variable language_">self</span>.cost = <span class="hljs-number">0</span>  <br>        <span class="hljs-variable language_">self</span>.heuristic = <span class="hljs-variable language_">self</span>.calculate_heuristic()  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_heuristic</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-comment"># 启发式函数：计算当前状态与目标状态的错位数码数量  </span><br>        target = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>]  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.state)) <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.state[i] != target[i] <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.state[i] != <span class="hljs-number">0</span>)  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.cost + <span class="hljs-variable language_">self</span>.heuristic &lt; other.cost + other.heuristic  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;State: <span class="hljs-subst">&#123;self.state&#125;</span>, Cost: <span class="hljs-subst">&#123;self.cost&#125;</span>, Heuristic: <span class="hljs-subst">&#123;self.heuristic&#125;</span>, Action: <span class="hljs-subst">&#123;self.action&#125;</span>&quot;</span> <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_neighbors</span>(<span class="hljs-params">node</span>):  <br>    zero_index = node.state.index(<span class="hljs-number">0</span>)  <br>    zero_row, zero_col = <span class="hljs-built_in">divmod</span>(zero_index, <span class="hljs-number">3</span>)  <br>    neighbors = []  <br>    actions = [(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)]  <span class="hljs-comment"># 上、下、左、右  </span><br>    <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions:  <br>        new_row, new_col = zero_row + action[<span class="hljs-number">0</span>], zero_col + action[<span class="hljs-number">1</span>]  <br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= new_row &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= new_col &lt; <span class="hljs-number">3</span>:  <br>            new_index = new_row * <span class="hljs-number">3</span> + new_col  <br>            new_state = [num <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(node.state) <span class="hljs-keyword">if</span> i != zero_index]  <br>            new_state.insert(new_index, <span class="hljs-number">0</span>)  <br>            neighbors.append(Node(new_state, node, action))  <br>    <span class="hljs-keyword">return</span> neighbors  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve_puzzle</span>(<span class="hljs-params">initial_state</span>):  <br>    root = Node(initial_state)  <br>    frontier = []  <br>    explored = <span class="hljs-built_in">set</span>()  <br>    heapq.heappush(frontier, root)  <br>  <br>    <span class="hljs-keyword">while</span> frontier:  <br>        current = heapq.heappop(frontier)  <br>        <span class="hljs-keyword">if</span> current.state == [<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>,<br>                             <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <br>                             <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>]:  <br>            <span class="hljs-comment"># 找到目标状态，构建路径  </span><br>            path = []  <br>            <span class="hljs-keyword">while</span> current:  <br>                path.append((current.action, current.state))  <br>                current = current.parent  <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(path)-<span class="hljs-number">1</span>, path[::-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 返回步数和路径（逆序）  </span><br>        explored.add(<span class="hljs-built_in">tuple</span>(current.state))  <br>        <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> get_neighbors(current):  <br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">tuple</span>(neighbor.state) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> explored:  <br>                neighbor.cost = current.cost + <span class="hljs-number">1</span>  <br>                heapq.heappush(frontier, neighbor)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>  <span class="hljs-comment"># 没有找到解  </span><br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_solution</span>(<span class="hljs-params">steps, path</span>):  <br>    <span class="hljs-keyword">if</span> steps <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有找到解决方案！&quot;</span>)  <br>        <span class="hljs-keyword">return</span>  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最少步骤: <span class="hljs-subst">&#123;steps&#125;</span>&quot;</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;路径:&quot;</span>)  <br>    <span class="hljs-keyword">for</span> action, state <span class="hljs-keyword">in</span> path:  <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;动作: <span class="hljs-subst">&#123;action&#125;</span>, 状态:&quot;</span>)  <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):  <br>            row = <span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">str</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> state[i*<span class="hljs-number">3</span>:(i+<span class="hljs-number">1</span>)*<span class="hljs-number">3</span>])  <br>            <span class="hljs-built_in">print</span>(row)  <br>        <span class="hljs-built_in">print</span>()  <br>  <br>initial_state = [<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <br>                 <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <br>                 <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>]  <span class="hljs-comment"># 初始状态  </span><br>steps, path = solve_puzzle(initial_state)  <br>print_solution(steps, path)<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="/img/image-20240413195737281.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>人工智能与专家系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HW</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>献给挚爱的小狗</title>
    <link href="/2024/07/07/%E7%8C%AE%E7%BB%99%E6%8C%9A%E7%88%B1%E7%9A%84%E5%B0%8F%E7%8B%97/"/>
    <url>/2024/07/07/%E7%8C%AE%E7%BB%99%E6%8C%9A%E7%88%B1%E7%9A%84%E5%B0%8F%E7%8B%97/</url>
    
    <content type="html"><![CDATA[<p><em>When age chills the blood, when our pleasures are past</em></p><p><em>当岁月让热血冷却，让欢乐远去</em></p><p><em>For years fleet away with the wings of the dove</em></p><p><em>年月就像白鸽的翅膀般飞走</em></p><p><em>The dearest remembrance will still be the last</em></p><p><em>然而，最深切的记忆则会永存</em></p><p><em>Our sweetest memorial the first kiss of love</em></p><p><em>我们最甜蜜的记忆，那最初的一吻</em></p><p><img src="/img/forever.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>LOVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FOREVER</tag>
      
      <tag>LOVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
